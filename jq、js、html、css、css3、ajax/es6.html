<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- 
        变量声明
        1. let  变量声明

            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区(TDZ, Temporal Dead Zone) 
                -> let语句之前的部分称为该变量的“暂时性死区”，在该区域内变量是不可用的，直到离开该区域才恢复可用, 即变量要先声明后使用

            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

        2. const 跨模块常量

            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区
            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

            -> 声明时必须立即初始化，否则属于语法错误 *
            -> 初始化后，不能代码修改值 (如果是引用值，则不能修改指向的地址)
            -> 使用 export 和 import 命令，我们可以让它在多个模块间共享
     -->

     <!-- 
        解构赋值

        1. 数组的解构赋值 -> 等号右边必须是数组(可遍历的结构，原始变量和{}不属于)
            var [a, b, c] = [1, 2, 3];
            var a = 1, b = 2, c = 3;    // 上面的代码等价于这行代码

            let [a, [b], d] = [1, [2, 3], 4];    // a:1, b:2, d:4
            let [x, , y]    = [1, 2, 3];         // x:1, y:3
            let [foo]       = [];                // foo: undefined
            let [bar, foo]  = [1];               // foo: undefined

                -> 一一匹配，少的为undefined，多的舍去，空缺位自动跳过


            默认值 : 仅当等号右边的元素是undefined时，默认值才起效
                let [x = 10] = [20]             // x:20
                let [x = 10] = [undefined]      // x:10  
                var [x = 1]  = [null];          // x:null

                function f() { console.log('aaa'); }
                let [x = f()] = [1];            // 右边不等于undefined，因此f()不会调用, x：1

                默认值可以引用其他变量，但必须声明
                let [x = 1, y = x] = [];        // x:1, y:1
                let [x = 1, y = x] = [2];       // x:2, y:2
                let [x = 1, y = x] = [2, 3];    // x:2, y:3
                let [x = y, y = 1] = [];        // ReferenceError，x引用y的值时，y还没声明

            
            练习：数组转对象
                    let points = [[30, 50], [1, 6], [6, 10]];
                    var obj = points.map( ([x, y]) => ({x, y}) );

                    console.log(obj)    // [{x:30, y:50}, {...}, {...}]


        2. 对象的解构赋值 -> 根据属性名进行映射，与顺序无关
            var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };    // 完整形式
            var { foo     , bar      } = { foo: "aaa", bar: "bbb" };    // 简写形式

            var { bar, foo } = { foo: "aaa", bar: "bbb" };    // foo:"aaa", bar:"bbb"
            var { baz }      = { foo: "aaa", bar: "bbb" };    // baz:undefined

            对象解构赋值的内部机制，是先找到同名属性，然后用等号右边的属性值给左边对应的属性值赋值。
            真正被赋值的是冒号右边的属性值，而不是左边的属性名
                -> 
                    var { foo: baz } = { foo: "aaa", bar: "bbb" };    // baz:"aaa", foo:not defined
                    
                    let obj = { first: 'hello', last: 'world' };
                    let { first: f, last: l } = obj;                  // f:'hello', l:'world'

            默认值 : 默认值仅当右边找不到同名属性，或同名属性值为undefined时起效
                ->
                    var {x, y = 5} = {x: 1};            // x:1, y:5
                    var {x = 3} = {x: null};            // x:null
                    var {x = 3} = {x: undefined};       // x:3

            嵌套 : 嵌套的父属性如果不存在，则子元素没意义
            
            解构已声明的变量 : 用括号包裹，不能让花括号处于行首
                -> 
                    var x;
                    {x} = {x: 1};     // 语法错误
                    ({x} = {x: 1});    // 正确的写法

            利用对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量
                -> 
                    let { random, sin, cos, floor } = Math;


        3. 字符串的解构赋值 -> 字符串作为类数组对象，同时具备了数组和对象的特性

            字符串可以看做数组进行结构
            ->
                const [a, b, c, d, e] = 'hello';    // a:"h", b:"e", c:"l", d:"l", e:"o",

            字符串作为类数组对象，拥有length属性。
            -> 
                let {length : len} = 'hello';       // len:5

        4. 函数参数的解构赋值
            -> add()的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引
                function add([x, y]){
                    return x + y;
                }
                add([1, 2])     // 3    
            
            默认值 : 实参为空对象或者无参调用，函数形参使用默认值
                -> 
                    function move({x = 1, y = 1} = {x : 0, y : 0}) {
                        return [x, y];
                    }

                    move({x: 3, y: 8});     // [3, 8]
                    move({x: 3});           // [3, 1]，y使用默认值
                    move({});               // [1, 1]，空对象，x、y均使用默认值
                    move();                 // [0, 0], 无参调用时使用 {x : 0, y : 0} 解构 {x = 1, y = 1}

                ->  无参调用
                        下面的写法不是解构赋值，而是给函数的参数设定默认值，只有在无参调用时默认值才起效
                        function move({x, y} = { x: 0, y: 0 }) {
                            return [x, y];
                        }

                        move({x: 3, y: 8});     // [        3,         8]
                        move({x: 3});           // [        3, undefined]，x正常赋值，默认值无效，y属性不存在，因此是undefined
                        move({});               // [undefined, undefined]，空对象也是实参，默认值无效，x、y属性都不存在，都是undefined
                        move();                 // [        0,         0]，无参调用，默认值起效
            
        5. 圆括号问题
            -> 一个式子到底是模式，还是表达式，只有解析到（或解析不到）等号才能知道

                        模式外面不能带括号，整个赋值语句可以

            1) 变量声明语句中，模式不能带有圆括号
                -> 
                    // 下面6种写法都会报错
                    let [(a)] = [1];
                    let {x: (c)} = {};
                    let ({x: c}) = {};
                    let {(x: c)} = {};
                    let {(x): c} = {};
                    let { o: ({ p: p }) } = { o: { p: 2 } };

            2) 函数参数中，模式不能带有圆括号
                -> 
                    // 函数参数也属于变量声明，因此不能带有圆括号
                    function f([(z)]) {
                        return z; 
                    }

            3) 不能将整个模式，或嵌套模式中的一层，放在圆括号之中
                ->
                    // 将整个模式放在圆括号之中，会报错
                    ({ p: a }) = { p: 42 };
                    ([a]) = [5];

                    // 将嵌套模式的一层放在圆括号之中，会报错。
                    [({ p: a }), { x: c }] = [{}, {}];

            4) 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号
                ->
                    [(b)] = [3]; // 正确
                    ({ p: (d) } = {}); // 正确
                    [(parseInt.prop)] = [3]; // 正确
                    
        解构赋值的用途

            1. 交换变量的值
                let x = 1, y = 2
                [x, y] = [y, x]

                
            2. 从函数返回多个值
                -> 
                    // 返回一个数组
                    function example() { return [1, 2, 3]; }
                    var [a, b, c] = example();

                    // 返回一个对象
                    function example() { return { foo: 1, bar: 2 }; }
                    var { foo, bar } = example();
                    

            3. 函数参数的默认值
                -> 
                    // bar, baz 等参数如果不指定，就用默认值代替，本质是对象的解构赋值
                    // 避免了在函数体内再写 var bar = config.bar || true 等检测代码
                    function func (foo, {
                        bar = true,             -> func(1, {});
                        baz = function () {},
                        ......
                    } = {
                        bar : true              -> 兼容直接调用 func(1);
                        baz : function () {}
                    }) {
                        // do something
                    }


            4. 提取json数据
                -> 
                    var jsonData = {
                        "id" : 42,
                        "status" : "OK",
                        "data" : [867, 5309]
                    }
                    let { id, status, data: number } = jsonData;
                    console.log(id, status, number)    // 42, OK, [867, 5309]


            5. 遍历Map
                -> 
                    // Map 类型是 ES6 引入的集合类型，以键值对方式存储数据
                    var map = new Map();
                    map.set('first', 'hello');
                    map.set('second', 'world');

                    // for...of 是 ES6 引入的循环方式，类似 for...in
                    for (let [key, value] of map) {
                    console.log(key + " is " + value);
                    }
                    // first is hello
                    // second is world

                    // 也可以单独获取键，或者值
                    for (let [key]     of map) { ... }
                    for (let [, value] of map) { ... }    // 注意逗号不能省，这是数组的解构赋值


            6. 输入模块的指定方法
                ->
                    // 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
                    const { SourceMapConsumer, SourceNode } = require("source-map");

      -->

      <!-- 
          字符串的扩展

            新增的方法 : 
                1) charAt()  ->  at() 返回字符串给定位置的字符,可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符
                
                2) indexOf()  确定一个字符串是否包含在另一个字符串中
                    -> 
                        includes()：返回布尔值，表示是否找到了参数字符串。
                        startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
                        endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

                        这三个方法都支持第二个参数，表示开始搜索的位置。
                            let s = 'Hello world!';
                            s.startsWith('world', 6) // true
                            s.endsWith('Hello', 5) // true
                            s.includes('Hello', 6) // false

                            ->上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。
                            它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。

                3) repeat(n) 方法返回一个新字符串，表示将原字符串重复n次
                    -> 
                        如果n为小数，先Math.floor()
                        如果n为字符串，先转为数字

                4) padStart(), padEnd() 字符串补全长度的功能
                    ->
                        'x'.padStart(5, 'ab') // 'ababx'
                        'x'.padStart(4, 'ab') // 'abax'

                        'x'.padEnd(5, 'ab') // 'xabab'
                        'x'.padEnd(4, 'ab') // 'xaba'

                

            模板字符串 -> 特殊的字符串 (反引号 波浪符那个)
            -> 
                1. 可以按照想要的格式显示，不用换行转义符
                    let str = `life is shit, 
                                but fantastic.`

                2. 可以在模板字符串中添加变量、表达式、函数 ( ${} )
                    -> 变量
                        let name = 'sunday';
                        var str = `name = ${name}`;

                    -> 表达式
                        let a = 10, b = 1;
                        var str = `a + b = ${a + b}`
                        
                    -> 函数 
                        let arr = [1, 2, 3, 4, 5];
                        let str = `${arr.map(function (ele) {
                            return `${ele * 2}`;
                        })}`;
                
            
            标签模板 (函数调用的特殊形式)
            -> 第一个参数是个数组，数组的内容是模板字符串中除了花括号表达式以外的内容 (最后补空字符串)*
               从第二个参数起就是花括号表达式计算的结果
            
                function hello(s, v1, v2) {
                    console.log(s[0]);          // "Hello "
                    console.log(s[1]);          // " world "
                    console.log(s[2]);          // ""
                    console.log(v1);            // 15
                    console.log(v2);            // 50

                    return "OK";
                }

                var a = 5, b = 10;
                hello`Hello ${ a + b } world ${ a * b}`;   // 相当于 -> hello(['Hello ', ' world ', ''], 15, 50)

                
                标签模板的应用 : 过滤html字符串

                &quot -> """
                &amp -> "&"
                &lt -> "<"
                &gt -> ">"
                &nbsp -> " "

                function safeHTML (data) {
                    let str = data[0];
                    for (let i = 1; i < arguments.length; i ++) {
                        let arg = String(arguments[i]);
                        str += arg.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        str += data[i];
                    }
                    return str;
                }
                var name = '<script>111<\/script>';
                safeHTML`hello ${name}, welcome to beijing`;
       -->
       <!-- 
            函数扩展
                1. 函数参数的默认值 (可以和解构赋值一起使用)

                    1) 普通用法
                        ->  function log(x, y = 'World') {
                                console.log(x, y);
                            }

                            log('Hello')          // Hello World
                            log('Hello', 'China') // Hello China
                            log('Hello', '')      // Hello

                    2) 解构赋值
                        ->  // 写法一
                            function m1( {x = 0, y = 0} = {} ) {
                                return [x, y];
                            }

                            // 写法二
                            function m2( {x, y} = { x: 0, y: 0 } ) {
                                return [x, y];
                            }

                            m1()                    // [0, 0]
                            m2()                    // [0, 0]
                            
                            m1( {x: 3, y: 8} )      // [3, 8]
                            m2( {x: 3, y: 8} )      // [3, 8]
                            
                            m1( {x: 3} )            // [3, 0]
                            m2( {x: 3} )            // [3, undefined]
                            
                            m1( {} )                // [0, 0];
                            m2( {} )                // [undefined, undefined]

                            m1( {z: 3} )            // [0, 0]
                            m2( {z: 3} )            // [undefined, undefined]

                    ->  
                        每个函数都有一个length属性，记录参数列表中参数的个数，
                        如果指定了默认值的，将不计入length，即length表示期望接收到的参数的个数

                    -> 
                        如果参数的默认值也是一个参数或者一个函数，那么需要注意它的作用域：参数列表 > 函数外部

                        一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）
                        等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的

                        eg:
                            let x = 1;                                              let x = 1;
                            function f(x, y = x) {                                  function f(y = x) {
                                console.log(y);                                         let x = 2;
                            }                                                           console.log(y);
                                                                                    }
                            // 先 x=2，然后 y=x 因而 y=2                            // 参数列表中没有x，因此只能从外围获取，x=1
                            // let x=1在这里并没有起到作用                          // 之后 y=x 因而 y=1，这之后 x=2 只影响函数内部的 x，不影响 y      
                            f(2)  // 2                                              f() // 1

                        ----------------------------------------------------------------------------------------------------------------------------

                            var x = 1;                                              var x = 1;
                            function foo(x, y = function() { x = 2; }) {            function foo(x, y = function() { x = 2; }) {
                                var x = 3;                                              x = 3;
                                y();                                                    y();
                                console.log(x);                                         console.log(x);
                            }                                                       }

                            foo() // 3                                              foo() // 2
                            x // 1                                                  x // 1

                            上面代码中，函数foo的参数形成一个单独作用域。这个          如果将var x = 3的var去除，函数foo的内部变量x就指向
                            作用域里面，首先声明了变量x，然后声明了变量y，y的          第一个参数x，与匿名函数内部的x一致，所以最后输出2，而
                            默认值是一个匿名函数。这个匿名函数内部的变量x，指          外部的全局变量x依然不受影响
                            向同一个作用域的第一个参数x。函数foo内部又声明了
                            一个内部变量x，该变量与第一个参数x由于不是同一个作
                            用域，所以不是同一个变量，因此执行y后，内部变量x和
                            外部全局变量x的值都没变。
                            

                    应用 : 参数为空时报错
                        ->
                            function throwInMissing () {
                                throw new Error('Missing Parameter');
                            }
                            function func (param = throwInMissing()){
                                console.log(param);
                            }
                            func();


                2. REST参数 : 允许我们将一个不定数量的参数表示为一个数组, 只能放在最后

                    -> 剩余参数和 arguments对象之间的区别主要有三个：
                        1) 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
                        2) arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。
                        3) arguments对象还有一些附加的属性 （如callee属性）

                    function add (a, ...arg) { 
                        console.log(arg);   // [2, 3, 4]
                        arg.forEach(function (ele) {
                            do something ...
                        })
                        console.log(arg);
                    }
                    add(2, 2, 3, 4);

                    * arr = [1, 2]  ->  ...arr = 1, 2



                3. 箭头函数     使用箭头 ( => ) 定义函数
                    ->  var f = v => v;
                        //  等同于
                        var f = function (v) {
                            return v;
                        }

                    1) 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分

                        var f = () => 5; -> var f = function () { return 5 }

                        var sum = (num1, num2) => num1 + num2;
                        // 等同于
                        var sun = function(num1, num2) {
                            return num1 + num2;
                        }

                    2) 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来
                    
                        let f = (x, y) => {
                            let result = x + y;
                            return result * 2;
                        }

                    3) 如果函数执行返回一个对象，需要用（）包裹

                        let f = id => ({ id : id, name : 'sunday'});


                    注意点：
                        -> 
                            1) 箭头函数的 this 总是指向函数定义时所在的作用域，而不是指向运行时所在的作用域（即箭头函数的this为父函数的this）
                            2) 箭头函数没有arguments，用rest参数替代
                            3) 不能当做构造函数，因为没有独立的执行上下文
                            4) 不可以使用yield命令，因此箭头函数不能用作 Generator 函数

                        
                        箭头函数this问题 ：
                            ->
                                function Timer() {
                                    this.s1 = 0;
                                    this.s2 = 0;
                                    // 箭头函数
                                    setInterval(() => this.s1++, 1000);  -> this指向Timer
                                    // 普通函数
                                    setInterval(function () {            -> this指向window
                                        this.s2++;
                                    }, 1000);
                                }

                                var timer = new Timer();

                                setTimeout(() => console.log('s1: ', timer.s1), 3100);  //3
                                setTimeout(() => console.log('s2: ', timer.s2), 3100);  //0

        -->
        <!--
            数组的扩展

                1. 扩展运算符 ( ... ) rest参数的逆运算
                     * ...[1, 2, 3] -> 1, 2, 3

                    // ES5 的写法
                    Math.max.apply(null, [14, 3, 77])
                    // ES6 的写法
                    Math.max(...[14, 3, 77])
                    // 等同于
                    Math.max(14, 3, 77);

                    // ES5的 写法
                    var arr1 = [0, 1, 2];
                    var arr2 = [3, 4, 5];
                    Array.prototype.push.apply(arr1, arr2);
                    // ES6 的写法
                    let arr1 = [0, 1, 2];
                    let arr2 = [3, 4, 5];
                    arr1.push(...arr2);

                    扩展运算符的应用 : 
                        1) 复制数组（深度复制）
                            let arr = [1, 2]
                            let arr1 = [...arr]

                        2) 合并数组
                            const arr1 = ['a', 'b'];
                            const arr2 = ['c'];
                            const arr3 = ['d', 'e'];

                            // ES5 的合并数组
                            arr1.concat(arr2, arr3);
                            // [ 'a', 'b', 'c', 'd', 'e' ]

                            // ES6 的合并数组
                            [...arr1, ...arr2, ...arr3]
                            // [ 'a', 'b', 'c', 'd', 'e' ]

                        3) 字符串转数组 -> 能够正确识别四个字节的 Unicode 字符
                            [...'hello']
                            // [ "h", "e", "l", "l", "o" ]

                        4) 具有 Iterator 接口的对象 -> 任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组（非类数组）
                            
                                let divList = document.getElementsByTagName('div');
                                console.log(divList)
                                let arrList = [...divList];
                                console.log(arrList)

                        5)  Map 和 Set 结构，Generator 函数

                2. 新增的方法
                    1)  Array.from() -> 类数组、具有Iterator接口的对象 转为 数组

                        兼容 :  const toArray = (() => 
                                    Array.from ? Array.from : obj => [].slice.call(obj)
                                )();

                        实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合

                        以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。

                        ->
                            // NodeList对象
                            let ps = document.querySelectorAll('p');
                            Array.from(ps).filter(p => {
                                return p.textContent.length > 100;
                            });

                            // arguments对象
                            function foo() {
                                var args = Array.from(arguments);
                                // ...
                            }

                        .from()的第二个参数 : Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组
                        
                        ->
                            Array.from(arrayLike, x => x * x);
                            // 等同于
                            Array.from(arrayLike).map(x => x * x);

                            Array.from([1, 2, 3], (x) => x * x)
                            // [1, 4, 9]
                        ------------------------------------------------------------------------------------
                            Array.from([1, , 2, , 3], (n) => n || 0)
                            // [1, 0, 2, 0, 3]
                        ------------------------------------------------------------------------------------
                            function typesOf () {
                                return Array.from(arguments, value => typeof value)
                            }
                            typesOf(null, [], NaN)
                            // ['object', 'object', 'number']
                
                    2)  Array.of() -> 可以替代 Array() / new Array()

                    3)  .find() -> 类似 .filter() ，差别 .find()找到一个符合条件的就停止,返回符合条件的元素  .filter()找到符合条件的全部数据,返回一个数组

                    4)  .findIndex() 
                            -> 
                            数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置
                            如果所有成员都不符合条件，则返回-1

                    5)  .includes -> 方法返回一个布尔值，表示某个数组是否包含给定的值,可以判断NaN(indexOf不行，因为内部判断为===)
                        -> 兼容
                            const contains = (() => 
                                Array.prototype.includes 
                                ? (arr, str) => arr.includes(str) 
                                : (arr, str) => {
                                    arr.some(ele => ele === str)
                                }
                            )();

                    6)  .fill(n) -> 填充一个数组，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去

                    7)  arr.entries()，arr.keys() 和 arr.values()
                            keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历, 都返回一个 Iterator对象（有next() 方法开启迭代）

                        ->
                            for (let index of ['a', 'b'].keys()) {
                                console.log(index);
                            }
                            // 0
                            // 1

                            for (let elem of ['a', 'b'].values()) {
                                console.log(elem);
                            }
                            // 'a'
                            // 'b'

                            for (let [index, elem] of ['a', 'b'].entries()) {
                                console.log(index, elem);
                            }
                            // 0 "a"
                            // 1 "b"

                3. 数组的空位
                        ES6 基本统一把数组的空位转为undefined字符串
        

                        ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。
                        -> 
                            forEach(), filter(), reduce(), every() 和some()都会跳过空位。
                            map()会跳过空位，但会保留这个值
                            join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。

                            // forEach方法
                            [,'a'].forEach((x,i) => console.log(i)); // 1

                            // filter方法
                            ['a',,'b'].filter(x => true) // ['a','b']

                            // every方法
                            [,'a'].every(x => x==='a') // true

                            // reduce方法
                            [1,,2].reduce((x,y) => x+y) // 3

                            // some方法
                            [,'a'].some(x => x !== 'a') // false

                            // map方法
                            [,'a'].map(x => 1) // [,1]

                            // join方法
                            [,'a',undefined,null].join('#') // "#a##"

                            // toString方法
                            [,'a',undefined,null].toString() // ",a,,"
                    
          -->

        <!-- 
            对象的扩展

                1. 对象的简写
                    -> 
                        let obj = {
                            foo : foo，
                            //等同于
                            foo，

                            add : function (x, y) {},
                            //等同于
                            add (x, y) {},
                        }

                2. 新增方法
                    1) Object.assigns() -> 对象合并 浅拷贝(除了 null/undefined )

                    2) Object.getOwnPropertyDescriptor(obj, prop) -> 获取对象某属性的描述对象
                        ->
                            let obj = { foo: 123 };
                            Object.getOwnPropertyDescriptor(obj, 'foo')
                            //  {
                            //    value: 123,
                            //    writable: true,   可修改  
                            //    enumerable: true,     可枚举
                            //    configurable: true        可删除
                            //  }

                            目前，有四个操作会忽略enumerable为false的属性
                            ->
                                for...in循环：只遍历对象自身的和继承的可枚举的属性
                                Object.keys()：返回对象自身的所有可枚举的属性的键名
                                JSON.stringify()：只串行化对象自身的可枚举的属性
                                Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性

                    3) Object.is(first, second) -> 比较两个值是否相等   
                        ->
                            +0 === -0 //true
                            NaN === NaN // false

                            Object.is(+0, -0) // false
                            Object.is(NaN, NaN) // true

         -->
        <!-- 
            Symbol -> 第七种原始数据，不能 new, 独一无二的值
                -> 
                    let s = Symbol();
                    typeof s; // symbol
                    s // Symbol()

                ->
                    let x = Symbol('sunday');  参数只适用于描述，和 Symbol 的取值没有任何关系，两个参数相等的 Symbol 并不相等，事实上，就不存在任何两个 Symbol 是相等的。
                    let y = Symbol('sunday');

                ->
                    Symbol 不能参与数值运算和字符串拼接，会报错  
                    可以显式地把 Symbol 转换成字符串或布尔值（不能转换为数值）

                -> 最主要的用途 : 作为属性名的symbol, 用 Symbol 定义属性时, 只能用[]的方式, 不能打点调用
                        Symbol 最常见的用途就是解决对象属性名冲突的问题，因为 Symbol 绝对不会冲突

                        let mySymbol = Symbol();

                        // 第一种写法
                        let o = {};
                        o[mySymbol] = 'hello';

                        // 第二种写法
                        let o = {
                        [mySymbol]: 'hello'
                        };

                        // 第三种写法
                        let o = {};
                        Object.defineProperty(o, mySymbol, {
                        value: 'hello'
                        });

                        // 以上写法均得到此结果
                        o[mySymbol] // hello

                ->  Symbol.for()
                        接受一个字符串参数，搜索是否已有以此为描述的 Symbol 存在，有则返回已有的，没有则新建并返回

                        let s1 = Symbol.for('foo');
                        let s2 = Symbol.for('foo');

                        s1 === s2 // true

                ->  Symbol.keyFor()
                        Symbol.for()在创建的同时会在全局进行登记，以进行检查，而普通的 Symbol 并不会登记
                        Symbol.keyFor()用于检查 Symbol 是否被注册过，注册过的正常返回注册用的参数，否则返回undefined

                        let s1 = Symbol.for('foo');
                        let s2 = Symbol('foo');

                        Symbol.keyFor(s1) // 'foo'
                        Symbol.keyFor(s2) // undefined
                        
         -->

         <!-- 
            es6 'class' 大发

            1. 
            2. 
            3. 
            4. 
            5. 
            6. 

          -->
</body>

</html>