<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- 
        变量声明
        1. let 
            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区(TDZ, Temporal Dead Zone) 
                -> let语句之前的部分称为该变量的“暂时性死区”，在该区域内变量是不可用的，直到离开该区域才恢复可用, 即变量要先声明后使用

            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

        2. const 跨模块常量
            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区
            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

            -> 声明时必须立即初始化，否则属于语法错误
            -> 初始化后，不能代码修改值 (如果是引用值，则不能修改指向的地址)
            -> 使用 export 和 import 命令，我们可以让它在多个模块间共享
     -->

     <!-- 
        解构赋值

        1. 数组的解构赋值 -> 等号右边必须是数组(可遍历的结构，原始变量和{}不属于)
            var [a, b, c] = [1, 2, 3];
            var a = 1, b = 2, c = 3;    // 上面的代码等价于这行代码

            let [a, [b], d] = [1, [2, 3], 4];    // a:1, b:2, d:4
            let [x, , y]    = [1, 2, 3];         // x:1, y:3
            let [foo]       = [];                // foo: undefined
            let [bar, foo]  = [1];               // foo: undefined

                -> 一一匹配，少的为undefined，多的舍去，空缺位自动跳过


            默认值 : 仅当等号右边的元素是undefined时，默认值才起效
                let [x = 10] = [20]             // x:20
                let [x = 10] = [undefined]      // x:10  
                var [x = 1]  = [null];          // x:null

                function f() { console.log('aaa'); }
                let [x = f()] = [1];            // 右边不等于undefined，因此f()不会调用, x：1

                默认值可以引用其他变量，但必须声明
                let [x = 1, y = x] = [];        // x:1, y:1
                let [x = 1, y = x] = [2];       // x:2, y:2
                let [x = 1, y = x] = [2, 3];    // x:2, y:3
                let [x = y, y = 1] = [];        // ReferenceError，x引用y的值时，y还没声明


        2. 对象的解构赋值 -> 根据属性名进行映射，与顺序无关
            var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };    // 完整形式
            var { foo     , bar      } = { foo: "aaa", bar: "bbb" };    // 简写形式

            var { bar, foo } = { foo: "aaa", bar: "bbb" };    // foo:"aaa", bar:"bbb"
            var { baz }      = { foo: "aaa", bar: "bbb" };    // baz:undefined

            对象解构赋值的内部机制，是先找到同名属性，然后用等号右边的属性值给左边对应的属性值赋值。
            真正被赋值的是冒号右边的属性值，而不是左边的属性名
                -> 
                    var { foo: baz } = { foo: "aaa", bar: "bbb" };    // baz:"aaa", foo:not defined
                    
                    let obj = { first: 'hello', last: 'world' };
                    let { first: f, last: l } = obj;                  // f:'hello', l:'world'

            默认值 : 默认值仅当右边找不到同名属性，或同名属性值为undefined时起效
                ->
                    var {x, y = 5} = {x: 1};            // x:1, y:5
                    var {x = 3} = {x: null};            // x:null
                    var {x = 3} = {x: undefined};       // x:3

            嵌套 : 嵌套的父属性如果不存在，则子元素没意义
            
            解构已声明的变量 : 用括号包裹，不能让花括号处于行首
                -> 
                    var x;
                    {x} = {x: 1};     // 语法错误
                    ({x} = {x: 1});    // 正确的写法

            利用对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量
                -> 
                    let { random, sin, cos, floor } = Math;


        3. 字符串的解构赋值 -> 字符串作为类数组对象，同时具备了数组和对象的特性

            字符串可以看做数组进行结构
            ->
                const [a, b, c, d, e] = 'hello';    // a:"h", b:"e", c:"l", d:"l", e:"o",

            字符串作为类数组对象，拥有length属性。
            -> 
                let {length : len} = 'hello';       // len:5

        4. 函数参数的解构赋值
            -> add()的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引
                function add([x, y]){
                    return x + y;
                }
                add([1, 2])     // 3    
            
            默认值 : 实参为空对象或者无参调用，函数形参使用默认值
                -> 
                    function move({x = 1, y = 1} = {x : 0, y : 0}) {
                        return [x, y];
                    }

                    move({x: 3, y: 8});     // [3, 8]
                    move({x: 3});           // [3, 1]，y使用默认值
                    move({});               // [1, 1]，空对象，x、y均使用默认值
                    move();                 // [0, 0], 无参调用时使用 {x : 0, y : 0} 解构 {x = 1, y = 1}

                ->  无参调用
                        下面的写法不是解构赋值，而是给函数的参数设定默认值，只有在无参调用时默认值才起效
                        function move({x, y} = { x: 0, y: 0 }) {
                            return [x, y];
                        }

                        move({x: 3, y: 8});     // [        3,         8]
                        move({x: 3});           // [        3, undefined]，x正常赋值，默认值无效，y属性不存在，因此是undefined
                        move({});               // [undefined, undefined]，空对象也是实参，默认值无效，x、y属性都不存在，都是undefined
                        move();                 // [        0,         0]，无参调用，默认值起效
            
        5. 圆括号问题
            -> 一个式子到底是模式，还是表达式，只有解析到（或解析不到）等号才能知道

            1) 变量声明语句中，模式不能带有圆括号
                -> 
                    // 下面3中写法都会报错
                    var [(a)] = [1];
                    var { x: (c) } = {};
                    var { o: ({ p: p }) } = { o: { p: 2 } };

            2) 函数参数中，模式不能带有圆括号
                -> 
                    // 函数参数也属于变量声明，因此不能带有圆括号
                    function f([(z)]) {
                        return z; 
                    }

            3) 不能将整个模式，或嵌套模式中的一层，放在圆括号之中
                ->
                    // 将整个模式放在圆括号之中，会报错
                    ({ p: a }) = { p: 42 };
                    ([a]) = [5];

                    // 将嵌套模式的一层放在圆括号之中，会报错。
                    [({ p: a }), { x: c }] = [{}, {}];

        
        解构赋值的用途

            1. 
            2. 
            3. 
            4. 
            5. 
            6. 






      -->
</body>

</html>