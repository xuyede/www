<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- 
        变量声明
        1. let 
            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区(TDZ, Temporal Dead Zone) 
                -> let语句之前的部分称为该变量的“暂时性死区”，在该区域内变量是不可用的，直到离开该区域才恢复可用, 即变量要先声明后使用

            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

        2. const 跨模块常量
            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区
            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

            -> 声明时必须立即初始化，否则属于语法错误
            -> 初始化后，不能代码修改值 (如果是引用值，则不能修改指向的地址)
            -> 使用 export 和 import 命令，我们可以让它在多个模块间共享
     -->

     <!-- 
        解构赋值

        1. 数组的解构赋值 -> 等号右边必须是数组(可遍历的结构，原始变量和{}不属于)
            var [a, b, c] = [1, 2, 3];
            var a = 1, b = 2, c = 3;    // 上面的代码等价于这行代码

            let [a, [b], d] = [1, [2, 3], 4];    // a:1, b:2, d:4
            let [x, , y]    = [1, 2, 3];         // x:1, y:3
            let [foo]       = [];                // foo: undefined
            let [bar, foo]  = [1];               // foo: undefined

                -> 一一匹配，少的为undefined，多的舍去，空缺位自动跳过


            默认值 : 仅当等号右边的元素是undefined时，默认值才起效
                let [x = 10] = [20]             // x:20
                let [x = 10] = [undefined]      // x:10  
                var [x = 1]  = [null];          // x:null

                function f() { console.log('aaa'); }
                let [x = f()] = [1];            // 右边不等于undefined，因此f()不会调用, x：1

                默认值可以引用其他变量，但必须声明
                let [x = 1, y = x] = [];        // x:1, y:1
                let [x = 1, y = x] = [2];       // x:2, y:2
                let [x = 1, y = x] = [2, 3];    // x:2, y:3
                let [x = y, y = 1] = [];        // ReferenceError，x引用y的值时，y还没声明


        2. 对象的解构赋值 -> 根据属性名进行映射，与顺序无关
            var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };    // 完整形式
            var { foo     , bar      } = { foo: "aaa", bar: "bbb" };    // 简写形式

            var { bar, foo } = { foo: "aaa", bar: "bbb" };    // foo:"aaa", bar:"bbb"
            var { baz }      = { foo: "aaa", bar: "bbb" };    // baz:undefined

            对象解构赋值的内部机制，是先找到同名属性，然后用等号右边的属性值给左边对应的属性值赋值。
            真正被赋值的是冒号右边的属性值，而不是左边的属性名
                -> 
                    var { foo: baz } = { foo: "aaa", bar: "bbb" };    // baz:"aaa", foo:not defined
                    
                    let obj = { first: 'hello', last: 'world' };
                    let { first: f, last: l } = obj;                  // f:'hello', l:'world'

            默认值 : 默认值仅当右边找不到同名属性，或同名属性值为undefined时起效
                ->
                    var {x, y = 5} = {x: 1};            // x:1, y:5
                    var {x = 3} = {x: null};            // x:null
                    var {x = 3} = {x: undefined};       // x:3

            嵌套 : 嵌套的父属性如果不存在，则子元素没意义
            
            解构已声明的变量 : 用括号包裹，不能让花括号处于行首
                -> 
                    var x;
                    {x} = {x: 1};     // 语法错误
                    ({x} = {x: 1});    // 正确的写法

            利用对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量
                -> 
                    let { random, sin, cos, floor } = Math;


        3. 字符串的解构赋值 -> 字符串作为类数组对象，同时具备了数组和对象的特性

            字符串可以看做数组进行结构
            ->
                const [a, b, c, d, e] = 'hello';    // a:"h", b:"e", c:"l", d:"l", e:"o",

            字符串作为类数组对象，拥有length属性。
            -> 
                let {length : len} = 'hello';       // len:5

        4. 函数参数的解构赋值
            -> add()的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引
                function add([x, y]){
                    return x + y;
                }
                add([1, 2])     // 3    
            
            默认值 : 实参为空对象或者无参调用，函数形参使用默认值
                -> 
                    function move({x = 1, y = 1} = {x : 0, y : 0}) {
                        return [x, y];
                    }

                    move({x: 3, y: 8});     // [3, 8]
                    move({x: 3});           // [3, 1]，y使用默认值
                    move({});               // [1, 1]，空对象，x、y均使用默认值
                    move();                 // [0, 0], 无参调用时使用 {x : 0, y : 0} 解构 {x = 1, y = 1}

                ->  无参调用
                        下面的写法不是解构赋值，而是给函数的参数设定默认值，只有在无参调用时默认值才起效
                        function move({x, y} = { x: 0, y: 0 }) {
                            return [x, y];
                        }

                        move({x: 3, y: 8});     // [        3,         8]
                        move({x: 3});           // [        3, undefined]，x正常赋值，默认值无效，y属性不存在，因此是undefined
                        move({});               // [undefined, undefined]，空对象也是实参，默认值无效，x、y属性都不存在，都是undefined
                        move();                 // [        0,         0]，无参调用，默认值起效
            
        5. 圆括号问题
            -> 一个式子到底是模式，还是表达式，只有解析到（或解析不到）等号才能知道

            1) 变量声明语句中，模式不能带有圆括号
                -> 
                    // 下面3中写法都会报错
                    var [(a)] = [1];
                    var { x: (c) } = {};
                    var { o: ({ p: p }) } = { o: { p: 2 } };

            2) 函数参数中，模式不能带有圆括号
                -> 
                    // 函数参数也属于变量声明，因此不能带有圆括号
                    function f([(z)]) {
                        return z; 
                    }

            3) 不能将整个模式，或嵌套模式中的一层，放在圆括号之中
                ->
                    // 将整个模式放在圆括号之中，会报错
                    ({ p: a }) = { p: 42 };
                    ([a]) = [5];

                    // 将嵌套模式的一层放在圆括号之中，会报错。
                    [({ p: a }), { x: c }] = [{}, {}];

        
        解构赋值的用途

            1. 交换变量的值
                let x = 1, y = 2
                [x, y] = [y, x]

                
            2. 从函数返回多个值
                -> 
                    // 返回一个数组
                    function example() { return [1, 2, 3]; }
                    var [a, b, c] = example();

                    // 返回一个对象
                    function example() { return { foo: 1, bar: 2 }; }
                    var { foo, bar } = example();
                    

            3. 函数参数的默认值
                -> 
                    // bar, baz 等参数如果不指定，就用默认值代替，本质是对象的解构赋值
                    // 避免了在函数体内再写 var bar = config.bar || true 等检测代码
                    function func (foo, {
                        bar = true,             -> func(1, {});
                        baz = function () {},
                        ......
                    } = {
                        bar : true              -> 兼容直接调用 func(1);
                        baz : function () {}
                    }) {
                        // do something
                    }


            4. 提取json数据
                -> 
                    var jsonData = {
                        "id" : 42,
                        "status" : "OK",
                        "data" : [867, 5309]
                    }
                    let { id, status, data: number } = jsonData;
                    console.log(id, status, number)    // 42, OK, [867, 5309]


            5. 遍历Map
                -> 
                    // Map 类型是 ES6 引入的集合类型，以键值对方式存储数据
                    var map = new Map();
                    map.set('first', 'hello');
                    map.set('second', 'world');

                    // for...of 是 ES6 引入的循环方式，类似 for...in
                    for (let [key, value] of map) {
                    console.log(key + " is " + value);
                    }
                    // first is hello
                    // second is world

                    // 也可以单独获取键，或者值
                    for (let [key]     of map) { ... }
                    for (let [, value] of map) { ... }    // 注意逗号不能省，这是数组的解构赋值


            6. 输入模块的指定方法
                ->
                    // 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
                    const { SourceMapConsumer, SourceNode } = require("source-map");

      -->

      <!-- 
          字符串的扩展

            模板字符串 -> 特殊的字符串 (反引号 波浪符那个)
            -> 
                1. 可以按照想要的格式显示，不用换行转义符
                    let str = `life is shit, 
                                but fantastic.`

                2. 可以在模板字符串中添加变量、表达式、函数 ( ${} )
                    -> 变量
                        let name = 'sunday';
                        var str = `name = ${name}`;

                    -> 表达式
                        let a = 10, b = 1;
                        var str = `a + b = ${a + b}`
                        
                    -> 函数 
                        let arr = [1, 2, 3, 4, 5];
                        let str = `${arr.map(function (ele) {
                            return `${ele * 2}`;
                        })}`;
                
            
            标签模板 (函数调用的特殊形式)
            -> 第一个参数是个数组，数组的内容是模板字符串中除了花括号表达式以外的内容 (最后补空字符串)*
               从第二个参数起就是花括号表达式计算的结果
            
                function hello(s, v1, v2) {
                    console.log(s[0]);          // "Hello "
                    console.log(s[1]);          // " world "
                    console.log(s[2]);          // ""
                    console.log(v1);            // 15
                    console.log(v2);            // 50

                    return "OK";
                }

                var a = 5, b = 10;
                hello`Hello ${ a + b } world ${ a * b}`;   // 相当于 -> hello(['Hello ', ' world ', ''], 15, 50)

                
                标签模板的应用 : 过滤html字符串

                &quot -> """
                &amp -> "&"
                &lt -> "<"
                &gt -> ">"
                &nbsp -> " "

                function safeHTML (data) {
                    let str = data[0];
                    for (let i = 1; i < arguments.length; i ++) {
                        var arg = String(arguments[i]);
                        str += arg.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        str += data[i];
                    }
                }
                var name = '<script>111<\/script>';
                safeHTML`hello ${name}, welcome to beijing`;
       -->
       <!-- 
            函数扩展
                1. 函数参数的默认值 (可以和解构赋值一起使用)

                    1) 普通用法
                        ->  function log(x, y = 'World') {
                                console.log(x, y);
                            }

                            log('Hello')          // Hello World
                            log('Hello', 'China') // Hello China
                            log('Hello', '')      // Hello

                    2) 解构赋值
                        ->  // 写法一
                            function m1( {x = 0, y = 0} = {} ) {
                                return [x, y];
                            }

                            // 写法二
                            function m2( {x, y} = { x: 0, y: 0 } ) {
                                return [x, y];
                            }

                            m1()                    // [0, 0]
                            m2()                    // [0, 0]
                            
                            m1( {x: 3, y: 8} )      // [3, 8]
                            m2( {x: 3, y: 8} )      // [3, 8]
                            
                            m1( {x: 3} )            // [3, 0]
                            m2( {x: 3} )            // [3, undefined]
                            
                            m1( {} )                // [0, 0];
                            m2( {} )                // [undefined, undefined]

                            m1( {z: 3} )            // [0, 0]
                            m2( {z: 3} )            // [undefined, undefined]

                    ->  
                        每个函数都有一个length属性，记录参数列表中参数的个数，
                        如果指定了默认值的，将不计入length，即length表示期望接收到的参数的个数

                    -> 
                        如果参数的默认值也是一个参数或者一个函数，那么需要注意它的作用域：参数列表 > 函数外部
                        eg:
                            let x = 1;                                      let x = 1;
                            function f(x, y = x) {                          function f(y = x) {
                            console.log(y);                                     let x = 2;
                            }                                                   console.log(y);
                                                                            }
                            // 先 x=2，然后 y=x 因而 y=2                     // 参数列表中没有x，因此只能从外围获取，x=1
                            // let x=1在这里并没有起到作用                   // 之后 y=x 因而 y=1，这之后 x=2 只影响函数内部的 x，不影响 y      
                            f(2)  // 2                                      f() // 1



                2. REST参数 : 允许我们将一个不定数量的参数表示为一个数组

                    -> 剩余参数和 arguments对象之间的区别主要有三个：
                        1) 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
                        2) arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。
                        3) arguments对象还有一些附加的属性 （如callee属性）

                    function add (a, ...arg) { 
                        console.log(arg);   // [2, 3, 4]
                        arg.forEach(function (ele) {
                            do something ...
                        })
                        console.log(arg);
                    }
                    add(2, 2, 3, 4);

                    * arr = [1, 2]  ->  ...arr = 1, 2



                3. 箭头函数
                

        -->
        
</body>

</html>