<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <!-- 
        变量声明
        1. let 
            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区(TDZ, Temporal Dead Zone) 
                -> let语句之前的部分称为该变量的“暂时性死区”，在该区域内变量是不可用的，直到离开该区域才恢复可用, 即变量要先声明后使用

            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

        2. const 跨模块常量
            -> 变量声明不提升
            -> 不允许重复定义同一个变量
            -> 暂时性死区
            -> 块级作用域特性 (只在变量声明所在的代码块内有效 {...} )
            -> 不再属于全局变量,就算在全局中声明

            -> 声明时必须立即初始化，否则属于语法错误 *
            -> 初始化后，不能代码修改值 (如果是引用值，则不能修改指向的地址)
            -> 使用 export 和 import 命令，我们可以让它在多个模块间共享
     -->

     <!-- 
        解构赋值

        1. 数组的解构赋值 -> 等号右边必须是数组(可遍历的结构，原始变量和{}不属于)
            var [a, b, c] = [1, 2, 3];
            var a = 1, b = 2, c = 3;    // 上面的代码等价于这行代码

            let [a, [b], d] = [1, [2, 3], 4];    // a:1, b:2, d:4
            let [x, , y]    = [1, 2, 3];         // x:1, y:3
            let [foo]       = [];                // foo: undefined
            let [bar, foo]  = [1];               // foo: undefined

                -> 一一匹配，少的为undefined，多的舍去，空缺位自动跳过


            默认值 : 仅当等号右边的元素是undefined时，默认值才起效
                let [x = 10] = [20]             // x:20
                let [x = 10] = [undefined]      // x:10  
                var [x = 1]  = [null];          // x:null

                function f() { console.log('aaa'); }
                let [x = f()] = [1];            // 右边不等于undefined，因此f()不会调用, x：1

                默认值可以引用其他变量，但必须声明
                let [x = 1, y = x] = [];        // x:1, y:1
                let [x = 1, y = x] = [2];       // x:2, y:2
                let [x = 1, y = x] = [2, 3];    // x:2, y:3
                let [x = y, y = 1] = [];        // ReferenceError，x引用y的值时，y还没声明


        2. 对象的解构赋值 -> 根据属性名进行映射，与顺序无关
            var { foo: foo, bar: bar } = { foo: "aaa", bar: "bbb" };    // 完整形式
            var { foo     , bar      } = { foo: "aaa", bar: "bbb" };    // 简写形式

            var { bar, foo } = { foo: "aaa", bar: "bbb" };    // foo:"aaa", bar:"bbb"
            var { baz }      = { foo: "aaa", bar: "bbb" };    // baz:undefined

            对象解构赋值的内部机制，是先找到同名属性，然后用等号右边的属性值给左边对应的属性值赋值。
            真正被赋值的是冒号右边的属性值，而不是左边的属性名
                -> 
                    var { foo: baz } = { foo: "aaa", bar: "bbb" };    // baz:"aaa", foo:not defined
                    
                    let obj = { first: 'hello', last: 'world' };
                    let { first: f, last: l } = obj;                  // f:'hello', l:'world'

            默认值 : 默认值仅当右边找不到同名属性，或同名属性值为undefined时起效
                ->
                    var {x, y = 5} = {x: 1};            // x:1, y:5
                    var {x = 3} = {x: null};            // x:null
                    var {x = 3} = {x: undefined};       // x:3

            嵌套 : 嵌套的父属性如果不存在，则子元素没意义
            
            解构已声明的变量 : 用括号包裹，不能让花括号处于行首
                -> 
                    var x;
                    {x} = {x: 1};     // 语法错误
                    ({x} = {x: 1});    // 正确的写法

            利用对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量
                -> 
                    let { random, sin, cos, floor } = Math;


        3. 字符串的解构赋值 -> 字符串作为类数组对象，同时具备了数组和对象的特性

            字符串可以看做数组进行结构
            ->
                const [a, b, c, d, e] = 'hello';    // a:"h", b:"e", c:"l", d:"l", e:"o",

            字符串作为类数组对象，拥有length属性。
            -> 
                let {length : len} = 'hello';       // len:5

        4. 函数参数的解构赋值
            -> add()的参数不是数组，而是[x,y] = [1,2]的解构，在函数内部，x和y可以直接访问，不需要索引
                function add([x, y]){
                    return x + y;
                }
                add([1, 2])     // 3    
            
            默认值 : 实参为空对象或者无参调用，函数形参使用默认值
                -> 
                    function move({x = 1, y = 1} = {x : 0, y : 0}) {
                        return [x, y];
                    }

                    move({x: 3, y: 8});     // [3, 8]
                    move({x: 3});           // [3, 1]，y使用默认值
                    move({});               // [1, 1]，空对象，x、y均使用默认值
                    move();                 // [0, 0], 无参调用时使用 {x : 0, y : 0} 解构 {x = 1, y = 1}

                ->  无参调用
                        下面的写法不是解构赋值，而是给函数的参数设定默认值，只有在无参调用时默认值才起效
                        function move({x, y} = { x: 0, y: 0 }) {
                            return [x, y];
                        }

                        move({x: 3, y: 8});     // [        3,         8]
                        move({x: 3});           // [        3, undefined]，x正常赋值，默认值无效，y属性不存在，因此是undefined
                        move({});               // [undefined, undefined]，空对象也是实参，默认值无效，x、y属性都不存在，都是undefined
                        move();                 // [        0,         0]，无参调用，默认值起效
            
        5. 圆括号问题
            -> 一个式子到底是模式，还是表达式，只有解析到（或解析不到）等号才能知道

                        模式外面不能带括号，整个赋值语句可以

            1) 变量声明语句中，模式不能带有圆括号
                -> 
                    // 下面6种写法都会报错
                    let [(a)] = [1];
                    let {x: (c)} = {};
                    let ({x: c}) = {};
                    let {(x: c)} = {};
                    let {(x): c} = {};
                    let { o: ({ p: p }) } = { o: { p: 2 } };

            2) 函数参数中，模式不能带有圆括号
                -> 
                    // 函数参数也属于变量声明，因此不能带有圆括号
                    function f([(z)]) {
                        return z; 
                    }

            3) 不能将整个模式，或嵌套模式中的一层，放在圆括号之中
                ->
                    // 将整个模式放在圆括号之中，会报错
                    ({ p: a }) = { p: 42 };
                    ([a]) = [5];

                    // 将嵌套模式的一层放在圆括号之中，会报错。
                    [({ p: a }), { x: c }] = [{}, {}];

            4) 可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号
                ->
                    [(b)] = [3]; // 正确
                    ({ p: (d) } = {}); // 正确
                    [(parseInt.prop)] = [3]; // 正确
                    
        解构赋值的用途

            1. 交换变量的值
                let x = 1, y = 2
                [x, y] = [y, x]

                
            2. 从函数返回多个值
                -> 
                    // 返回一个数组
                    function example() { return [1, 2, 3]; }
                    var [a, b, c] = example();

                    // 返回一个对象
                    function example() { return { foo: 1, bar: 2 }; }
                    var { foo, bar } = example();
                    

            3. 函数参数的默认值
                -> 
                    // bar, baz 等参数如果不指定，就用默认值代替，本质是对象的解构赋值
                    // 避免了在函数体内再写 var bar = config.bar || true 等检测代码
                    function func (foo, {
                        bar = true,             -> func(1, {});
                        baz = function () {},
                        ......
                    } = {
                        bar : true              -> 兼容直接调用 func(1);
                        baz : function () {}
                    }) {
                        // do something
                    }


            4. 提取json数据
                -> 
                    var jsonData = {
                        "id" : 42,
                        "status" : "OK",
                        "data" : [867, 5309]
                    }
                    let { id, status, data: number } = jsonData;
                    console.log(id, status, number)    // 42, OK, [867, 5309]


            5. 遍历Map
                -> 
                    // Map 类型是 ES6 引入的集合类型，以键值对方式存储数据
                    var map = new Map();
                    map.set('first', 'hello');
                    map.set('second', 'world');

                    // for...of 是 ES6 引入的循环方式，类似 for...in
                    for (let [key, value] of map) {
                    console.log(key + " is " + value);
                    }
                    // first is hello
                    // second is world

                    // 也可以单独获取键，或者值
                    for (let [key]     of map) { ... }
                    for (let [, value] of map) { ... }    // 注意逗号不能省，这是数组的解构赋值


            6. 输入模块的指定方法
                ->
                    // 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。
                    const { SourceMapConsumer, SourceNode } = require("source-map");

      -->

      <!-- 
          字符串的扩展

            新增的方法 : 
                1) charAt()  ->  at() 返回字符串给定位置的字符,可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符
                
                2) indexOf()  确定一个字符串是否包含在另一个字符串中
                    -> 
                        includes()：返回布尔值，表示是否找到了参数字符串。
                        startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。
                        endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

                        这三个方法都支持第二个参数，表示开始搜索的位置。
                            let s = 'Hello world!';
                            s.startsWith('world', 6) // true
                            s.endsWith('Hello', 5) // true
                            s.includes('Hello', 6) // false

                            ->上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。
                            它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。

                3) repeat(n) 方法返回一个新字符串，表示将原字符串重复n次
                    -> 
                        如果n为小数，先Math.floor()
                        如果n为字符串，先转为数字

                4) padStart(), padEnd() 字符串补全长度的功能
                    ->
                        'x'.padStart(5, 'ab') // 'ababx'
                        'x'.padStart(4, 'ab') // 'abax'

                        'x'.padEnd(5, 'ab') // 'xabab'
                        'x'.padEnd(4, 'ab') // 'xaba'

                

            模板字符串 -> 特殊的字符串 (反引号 波浪符那个)
            -> 
                1. 可以按照想要的格式显示，不用换行转义符
                    let str = `life is shit, 
                                but fantastic.`

                2. 可以在模板字符串中添加变量、表达式、函数 ( ${} )
                    -> 变量
                        let name = 'sunday';
                        var str = `name = ${name}`;

                    -> 表达式
                        let a = 10, b = 1;
                        var str = `a + b = ${a + b}`
                        
                    -> 函数 
                        let arr = [1, 2, 3, 4, 5];
                        let str = `${arr.map(function (ele) {
                            return `${ele * 2}`;
                        })}`;
                
            
            标签模板 (函数调用的特殊形式)
            -> 第一个参数是个数组，数组的内容是模板字符串中除了花括号表达式以外的内容 (最后补空字符串)*
               从第二个参数起就是花括号表达式计算的结果
            
                function hello(s, v1, v2) {
                    console.log(s[0]);          // "Hello "
                    console.log(s[1]);          // " world "
                    console.log(s[2]);          // ""
                    console.log(v1);            // 15
                    console.log(v2);            // 50

                    return "OK";
                }

                var a = 5, b = 10;
                hello`Hello ${ a + b } world ${ a * b}`;   // 相当于 -> hello(['Hello ', ' world ', ''], 15, 50)

                
                标签模板的应用 : 过滤html字符串

                &quot -> """
                &amp -> "&"
                &lt -> "<"
                &gt -> ">"
                &nbsp -> " "

                function safeHTML (data) {
                    let str = data[0];
                    for (let i = 1; i < arguments.length; i ++) {
                        let arg = String(arguments[i]);
                        str += arg.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
                        str += data[i];
                    }
                    return str;
                }
                var name = '<script>111<\/script>';
                safeHTML`hello ${name}, welcome to beijing`;
       -->
       <!-- 
            函数扩展
                1. 函数参数的默认值 (可以和解构赋值一起使用)

                    1) 普通用法
                        ->  function log(x, y = 'World') {
                                console.log(x, y);
                            }

                            log('Hello')          // Hello World
                            log('Hello', 'China') // Hello China
                            log('Hello', '')      // Hello

                    2) 解构赋值
                        ->  // 写法一
                            function m1( {x = 0, y = 0} = {} ) {
                                return [x, y];
                            }

                            // 写法二
                            function m2( {x, y} = { x: 0, y: 0 } ) {
                                return [x, y];
                            }

                            m1()                    // [0, 0]
                            m2()                    // [0, 0]
                            
                            m1( {x: 3, y: 8} )      // [3, 8]
                            m2( {x: 3, y: 8} )      // [3, 8]
                            
                            m1( {x: 3} )            // [3, 0]
                            m2( {x: 3} )            // [3, undefined]
                            
                            m1( {} )                // [0, 0];
                            m2( {} )                // [undefined, undefined]

                            m1( {z: 3} )            // [0, 0]
                            m2( {z: 3} )            // [undefined, undefined]

                    ->  
                        每个函数都有一个length属性，记录参数列表中参数的个数，
                        如果指定了默认值的，将不计入length，即length表示期望接收到的参数的个数

                    -> 
                        如果参数的默认值也是一个参数或者一个函数，那么需要注意它的作用域：参数列表 > 函数外部
                        eg:
                            let x = 1;                                              let x = 1;
                            function f(x, y = x) {                                  function f(y = x) {
                                console.log(y);                                         let x = 2;
                            }                                                           console.log(y);
                                                                                    }
                            // 先 x=2，然后 y=x 因而 y=2                            // 参数列表中没有x，因此只能从外围获取，x=1
                            // let x=1在这里并没有起到作用                          // 之后 y=x 因而 y=1，这之后 x=2 只影响函数内部的 x，不影响 y      
                            f(2)  // 2                                              f() // 1

                        ----------------------------------------------------------------------------------------------------------------------------

                            var x = 1;                                              var x = 1;
                            function foo(x, y = function() { x = 2; }) {            function foo(x, y = function() { x = 2; }) {
                                var x = 3;                                              x = 3;
                                y();                                                    y();
                                console.log(x);                                         console.log(x);
                            }                                                       }

                            foo() // 3                                              foo() // 2
                            x // 1                                                  x // 1

                    应用 : 参数为空时报错
                        ->
                            function throwInMissing () {
                                throw new Error('Missing Parameter');
                            }
                            function func (param = throwInMissing()){
                                console.log(param);
                            }
                            func();


                2. REST参数 : 允许我们将一个不定数量的参数表示为一个数组, 只能放在最后

                    -> 剩余参数和 arguments对象之间的区别主要有三个：
                        1) 剩余参数只包含那些没有对应形参的实参，而 arguments 对象包含了传给函数的所有实参。
                        2) arguments对象不是一个真正的数组，而剩余参数是真正的 Array实例，也就是说你能够在它上面直接使用所有的数组方法，比如 sort，map，forEach或pop。
                        3) arguments对象还有一些附加的属性 （如callee属性）

                    function add (a, ...arg) { 
                        console.log(arg);   // [2, 3, 4]
                        arg.forEach(function (ele) {
                            do something ...
                        })
                        console.log(arg);
                    }
                    add(2, 2, 3, 4);

                    * arr = [1, 2]  ->  ...arr = 1, 2



                3. 箭头函数     使用箭头 ( => ) 定义函数
                    ->  var f = v => v;
                        //  等同于
                        var f = function (v) {
                            return v;
                        }

                    1) 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分

                        var f = () => 5; -> var f = function () { return 5 }

                        var sum = (num1, num2) => num1 + num2;
                        // 等同于
                        var sun = function(num1, num2) {
                            return num1 + num2;
                        }

                    2) 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来
                    
                        let f = (x, y) => {
                            let result = x + y;
                            return result * 2;
                        }

                    3) 如果函数执行返回一个对象，需要用（）包裹

                        let f = id => ({ id : id, name : 'sunday'});


                    注意点：
                        -> 
                            1) 箭头函数的 this 总是指向函数定义时所在的作用域，而不是指向运行时所在的作用域（即箭头函数的this为父函数的this）
                            2) 箭头函数没有arguments，用rest参数替代
                            3) 不能当做构造函数，因为没有独立的执行上下文
                            4) 不可以使用yield命令，因此箭头函数不能用作 Generator 函数

                        
                        箭头函数this问题 ：
                            ->
                                function Timer() {
                                    this.s1 = 0;
                                    this.s2 = 0;
                                    // 箭头函数
                                    setInterval(() => this.s1++, 1000);  -> this指向Timer
                                    // 普通函数
                                    setInterval(function () {            -> this指向window
                                        this.s2++;
                                    }, 1000);
                                }

                                var timer = new Timer();

                                setTimeout(() => console.log('s1: ', timer.s1), 3100);  //3
                                setTimeout(() => console.log('s2: ', timer.s2), 3100);  //0

        -->
        <!--
            数组的扩展




          -->
</body>

</html>