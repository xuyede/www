<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
            前端模块化 
                -> node.js -> commonJS规范 -> 同步加载，适合服务端不适用于浏览器 
                -> AMD -> 异步加载，允许回调函数 -> require.js -> 推崇依赖提前 
                -> CMD -> 推崇就近依赖 -> sea.js 
                -> ES6

                1.模块化实现
                    1) 函数
                        function add (a, b) {
                            return a + b;
                        }
                        function show () {
                            console.log(add());
                        }

                            -> 一个函数一个功能，只能用于练习。。。

                    2) 对象
                        var ppt = {
                            len : 4,
                            init : function () {
                                this.show();
                            },
                            show : function () {
                                console.log(this.len);
                            }
                        }
                        ppt.init();

                            -> 有一个相对独立的作用域，但是，在外部可以改变里面的变量(ppt.len = 5)，不安全啊。。。
                    
                    3) 立即执行函数 + 返回对象
                        var way = (function () {
                            var len = 4;
                            function show () {
                                console.log(len);
                            }
                            return {
                                show : show
                            };
                        } ())
                        way.show();

                            -> 有独立的作用域，可以暴露指定接口

                    4) 立即执行函数 + 依赖传入实参(jQuery)
                        (function (a, b) {
                            b(a);
                        })(window, function (window) {
                            function jQuery () {

                            }
                            window.$ = window.jQuery = jQuery;
                        })

                        对一个大模块的功能添加(module为已有的功能模块)
                        module = (function (param) {
                            param.add = function (a, b) {
                                return a + b;
                            }
                            return param;
                        } (window.module || {}))

                            -> 有独立的作用域，可以把接口暴露给指定对象
                
                2.更好的模块化规范
                    -> 将属性或行为类似的内容放在同一个js文件中，把这个js文件称为模块
                       一个js文件就是一个模块，其内部定义的变量是属于这个模块的，不会
                       对外暴露，也就是说不污染全局变量

                    1) 独立
                    2) 完整
                    3) 依赖关系
                       
                    CommonJs模块规范 -> 同步加载，适用于服务端
                    AMD模块规范 -> 异步加载，允许指定回调函数，使用于浏览器
                        

                    重点* require.js
                        -> 管理模块之间的依赖性，便于代码的编写和维护

                        1.  <script src="./js/require.js" data-main="./js/main"></script>
                                -> data-main属性：指定网页程序的主模块，main.js文件会第一个被require.js加载
                                                  require.js默认文件后缀名为.js，所以可以把main.js写成main

                        2.  主模块的写法
                            ->  main.js 
                                    通过require()函数引入依赖的模块
                                    ->  require(['module1', 'module2'], function (module1, module2) {

                                            //some code here

                                        })

                                        require()函数第一个参数为数组，表示依赖的模块，第二个参数为回调函数
                                        当模块全部加载完后被调用，加载的模块会以参数形式传入该函数，从而在回
                                        调函数内部就可以使用这些模块

                                    通过require.config(),对模块的加载行为进行自定义,方法写在主模块头部
                                    ->  require.config({
                                            baseUrl : 'js' -> 改变根目录,则下面paths不用加js/
                                            paths : {
                                                //指定各个模块的加载路径,不能写文件后缀名
                                                'module1' : 'js/module1',
                                                'module2' : 'js/module2'
                                            }
                                        })

                        3.  AMD模块的写法(非主模块)
                            ->  假定现在有一个math.js文件，它定义了一个math模块
                                -> math.js
                                    通过define()函数包裹
                                    ->  define(function (){
                                    　　　　var add = function (x,y){
                                    　　　　　　return x+y;
                                    　　　　};
                                    　　　　return {
                                    　　　　　　add: add
                                    　　　　};
                                    　　});

                                -> main.js

                                　  require(['math'], function (math){
                            　　　　    alert(math.add(1,1));
                                　  });

                            ->  如果该模块还依赖于别的模块,那么define()函数的第一个参数，必须是一个数组
                                指明该模块的依赖性,并在main.js头部的require.config写明路径信息
                                -> math.js
                                    define(['myLib'], function(myLib){
                                　　　　function foo(){
                                　　　　　　myLib.doSomething();
                                　　　　}
                                　　　　return {
                                　　　　　　foo : foo
                                　　　　};
                                　　});
                                    
                                    
                    *重点 sea.js 
                        ->   CMD异步加载，和AMD主要区别在于，AMD推崇依赖前置，提前加载依赖，
                             而CMD推崇依赖就近，按需加载
                             
                        1.页面写法
                            seajs.use()引入主模块
                            -> index.html
                                <script src="./js/sea.js"></script>
                                <script>
                                    seajs.use('./js/main');
                                </script>
                        
                        2.主模块写法
                            define()定义模块，里面需要用到模块时，用require()引入
                            -> main.js
                                define(function (require, exports, module) {
                                    var math = require('math');
                                    console.log(math.add(1, 2));
                                })

                        3.模块写法
                            define()定义模块，用exports暴露出接口
                            -> math.js
                                define(function (require, exports, module) {
                                    function add (a, b) {
                                        return a + b;
                                    }

                                    exports.add = add;
                                    exports.str = 'sunday';   -> exports实际为一个对象，可以添加属性到math.js模块上
                                })
                        
     -->
     <!-- 
            重点*  webpack

                1. 前端工程化
                    开发规范、模块化开发、组件化开发、组件仓库
                    性能优化、部署、开发流程、开发工具

                2. 前端自动化构建工具
                    webpack、Grunt、Gulp

                3. webpack的使用
                    1) node.js、npm、git 支持

                    2) 基本命令
                        npm install webpack -g  -> 下载全局webpack
                        npm init  -> 初始化npm配置，生成package.json文件
                        npm install webpack --save-dev  -> 下载编写环境的webpack模块和配置文件(在自己电脑配置，传文件时不用传这个，只需传package.json)
                        npm install webpack-cli -g  -> 下载webpack-cli插件
                        webpack -> 运行webpack，生成出口文件main.js，在dist文件夹中(注意：需要在文件目录下创建src文件夹，src文件夹里面有个index.js的文件作为默认入口文件)
                        webpack -w  -> webpack项目进行打包并实时监控
                    3)  四个核心模块
                            -> 入口(entry: 默认为./src)
                                页面入口文件配置(html文件引入唯一的js文件)

                            -> 输出(output: 默认为./dist)
                                对应输出项配置(path:入口文件最终要输出到哪里, filename:输出文件的名称)

                            -> loader
                                处理非js文件

                            -> 插件(plugins)
                    4)
                    5)


      -->
</body>
</html>