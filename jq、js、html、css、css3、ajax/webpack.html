<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
            前端模块化 
                -> node.js -> commonJS规范 -> 同步加载，适合服务端不适用于浏览器 
                -> AMD -> 异步加载，允许回调函数 -> require.js -> 推崇依赖提前 
                -> CMD -> 推崇就近依赖 -> sea.js 
                -> ES6

                1.模块化实现
                    1) 函数
                        function add (a, b) {
                            return a + b;
                        }
                        function show () {
                            console.log(add());
                        }

                            -> 一个函数一个功能，只能用于练习。。。

                    2) 对象
                        var ppt = {
                            len : 4,
                            init : function () {
                                this.show();
                            },
                            show : function () {
                                console.log(this.len);
                            }
                        }
                        ppt.init();

                            -> 有一个相对独立的作用域，但是，在外部可以改变里面的变量(ppt.len = 5)，不安全啊。。。
                    
                    3) 立即执行函数 + 返回对象
                        var way = (function () {
                            var len = 4;
                            function show () {
                                console.log(len);
                            }
                            return {
                                show : show
                            };
                        } ())
                        way.show();

                            -> 有独立的作用域，可以暴露指定接口

                    4) 立即执行函数 + 依赖传入实参(jQuery)
                        (function (a, b) {
                            b(a);
                        })(window, function (window) {
                            function jQuery () {

                            }
                            window.$ = window.jQuery = jQuery;
                        })

                        对一个大模块的功能添加(module为已有的功能模块)
                        module = (function (param) {
                            param.add = function (a, b) {
                                return a + b;
                            }
                            return param;
                        } (window.module || {}))

                            -> 有独立的作用域，可以把接口暴露给指定对象
                
                2.更好的模块化规范
                    -> 将属性或行为类似的内容放在同一个js文件中，把这个js文件称为模块
                       一个js文件就是一个模块，其内部定义的变量是属于这个模块的，不会
                       对外暴露，也就是说不污染全局变量

                    1) 独立
                    2) 完整
                    3) 依赖关系
                       
                    CommonJs模块规范 -> 同步加载，适用于服务端
                    AMD模块规范 -> 异步加载，允许指定回调函数，使用于浏览器
                        

                    重点* require.js
                        -> 管理模块之间的依赖性，便于代码的编写和维护

                        1.  <script src="./js/require.js" data-main="./js/main"></script>
                                -> data-main属性：指定网页程序的主模块，main.js文件会第一个被require.js加载
                                                  require.js默认文件后缀名为.js，所以可以把main.js写成main

                        2.  主模块的写法
                            ->  main.js 
                                    通过require()函数引入依赖的模块
                                    ->  require(['module1', 'module2'], function (module1, module2) {

                                            //some code here

                                        })

                                        require()函数第一个参数为数组，表示依赖的模块，第二个参数为回调函数
                                        当模块全部加载完后被调用，加载的模块会以参数形式传入该函数，从而在回
                                        调函数内部就可以使用这些模块

                                    通过require.config(),对模块的加载行为进行自定义,方法写在主模块头部
                                    ->  require.config({
                                            baseUrl : 'js' -> 改变根目录,则下面paths不用加js/
                                            paths : {
                                                //指定各个模块的加载路径,不能写文件后缀名
                                                'module1' : 'js/module1',
                                                'module2' : 'js/module2'
                                            }
                                        })

                        3.  AMD模块的写法(非主模块)
                            ->  假定现在有一个math.js文件，它定义了一个math模块
                                -> math.js
                                    通过define()函数包裹
                                    ->  define(function (){
                                    　　　　var add = function (x,y){
                                    　　　　　　return x+y;
                                    　　　　};
                                    　　　　return {
                                    　　　　　　add: add
                                    　　　　};
                                    　　});

                                -> main.js

                                　  require(['math'], function (math){
                            　　　　    alert(math.add(1,1));
                                　  });

                            ->  如果该模块还依赖于别的模块,那么define()函数的第一个参数，必须是一个数组
                                指明该模块的依赖性,并在main.js头部的require.config写明路径信息
                                -> math.js
                                    define(['myLib'], function(myLib){
                                　　　　function foo(){
                                　　　　　　myLib.doSomething();
                                　　　　}
                                　　　　return {
                                　　　　　　foo : foo
                                　　　　};
                                　　});
                                    
                                    
                    *重点 sea.js 
                        ->   CMD异步加载，和AMD主要区别在于，AMD推崇依赖前置，提前加载依赖，
                             而CMD推崇依赖就近，按需加载
                             
                        1.页面写法
                            seajs.use()引入主模块
                            -> index.html
                                <script src="./js/sea.js"></script>
                                <script>
                                    seajs.use('./js/main');
                                </script>
                        
                        2.主模块写法
                            define()定义模块，里面需要用到模块时，用require()引入
                            -> main.js
                                define(function (require, exports, module) {
                                    var math = require('math');
                                    console.log(math.add(1, 2));
                                })

                        3.模块写法
                            define()定义模块，用exports暴露出接口
                            -> math.js
                                define(function (require, exports, module) {
                                    function add (a, b) {
                                        return a + b;
                                    }

                                    exports.add = add;
                                    exports.str = 'sunday';   -> exports实际为一个对象，可以添加属性到math.js模块上
                                })
                        
     -->
     <!-- 
            重点*  webpack
                    -> 任何静态资源都可以视作模块，然后模块之间也可以相互依赖，通过webpack对模块进行处理后，可以打包成我们想要的静态资源

                    1) 支持CommonJs/AMD/CMD模块，意思也就是我们基本可以无痛迁移旧项目。
                    2) 支持模块加载器和插件机制，可对模块灵活定制。特别是我最爱的babel-loader，有效支持ES6。
                    3) 可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。
                    4) 将样式文件和图片等静态资源也可视为模块进行打包。配合loader加载器，可以支持less等CSS预处理器。
                    5) 内置有source map，即使打包在一起依旧方便调试


                1. 前端工程化
                    开发规范、模块化开发、组件化开发、组件仓库
                    性能优化、部署、开发流程、开发工具

                2. 前端自动化构建工具
                    webpack、Grunt、Gulp

                3. webpack的使用
                    1) node.js、npm、git 支持

                    2) 基本命令
                        npm i webpack -g  -> 下载全局webpack
                        npm init  -> 初始化npm配置，生成package.json文件
                        npm i -D webpack  -> npm i -D 是 npm install --save-dev 的简写，是指安装模块并保存到 package.json 的 devDependencies
                        npm i webpack-cli -g  -> 下载webpack-cli插件
                        webpack -> webpack项目打包，默认生成出口文件main.js，在dist文件夹中(注意：需要在文件目录下创建src文件夹，src文件夹里面有个index.js的文件作为默认入口文件)
                        webpack -w  -> webpack进行项目打包并实时监控(退出，Ctrl+C)

                    3)  四个核心模块
                            -> entry: 页面入口文件配置,指定入口文件,可多个入口文件(可以动态生成，new Promise())
                                
                            -> output: html页面引入输出文件
                                path: 配置输出文件存放在本地的目录(path : path.resolve(__dirname, 'out') / path : __dirname + '/out')
                                filename: 输出文件的名称，如果是多个入口文件(filename : '[name].js')
                                publicPath: 当浏览器需要引用输入静态资源文件时,这个配置项指定输入文件的公共URL地址
                                crossOriginLoading: anonymous(默认) 在加载异步脚本(JSONP)资源时不会带上用户的Cookies；use-credentials带上
                                    
                            -> loader加载器
                                1) loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译
                                2) 一个 Loader 的职责是单一的，只需要完成一种转换
                                3) 在module.rules中配置

                            -> module: 配置如何处理模块
                            
                                rules: 配置模块的读取和解析规则,通常用来配置 Loader,为一个数组
                                    1) 条件匹配：通过 test 、 include 、 exclude 三个配置项来命中 Loader 要应用规则的文件
                                        test : 正则表达式,匹配文件类型 (/\.js$/ 、 /\.css$/ 、...)
                                        include : 只命中符合条件的文件(include : path.resolve(__diename, 'src') -> 命中src目录下的某文件)
                                        exclude : 排除选中的目录(exclude : path.resolve(__dirname, 'src') -> 排除src目录下的文件)

                                    2) 应用规则：对选中后的文件通过 use 配置项来应用 Loader,可以只应用一个 Loader 或者按照从后往前的顺序应用一组 Loader
                                        use : ['style-loader', 'css-loader?minimize'] -> 顺序从右往左
                                        
                                        在 Loader 需要传入很多参数时，你还可以通过一个 Object 来描述
                                            use: [
                                                {
                                                    loader : 'babel-loader',
                                                    options:{
                                                        cacheDirectory:true,
                                                    },
                                                    // enforce:'post' 的含义是把该 Loader 的执行顺序放到最后
                                                    // enforce 的值还可以是 pre，代表把 Loader 的执行顺序放到最前面
                                                    enforce:'post'
                                                },
                                            ]

                                    3) 重置顺序：一组 Loader 的执行顺序默认是从右到左执行，通过 enforce 选项可以让其中一个 Loader 的执行顺序放到最前或者最后


                                module : {
                                    rules : [
                                        {
                                            test : /\.css$/,
                                            use : ['style-loader', 'css-loader?minimize']
                                        }
                                    ]
                                }
                                


                            配置文件webpack.config.js (修改完配置文件后要重新对项目进行打包)
                                -> webpack.config.js

                                    const path = require('path');
                                    module.exports = {
                                        entry : './src/js/index.js',
                                        output : {
                                            path : __dirname + '/out'
                                            filename : 'demo.js'
                                        }，
                                        mode : 'development' -> 不压缩js文件  'production' -> 压缩
                                    }

                                    -> 当有多个入口文件时：
                                    module.exports = {
                                        entry : {
                                            index : './src/js/index.js',
                                            demo : './src/js/demo.js'
                                        },
                                        output : {
                                            path : __dirname + '/out',
                                            filename : '[name].bundle.js'
                                        }
                                    }

                    4)

                    5)


      -->
</body>
</html>