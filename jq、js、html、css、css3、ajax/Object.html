<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
        js对象机制
                    * 一切皆对象 -> 封装 继承 多态 -> 原型链(伪实现)
                    
                    1. 对象是一系列属性和方法的综合体,不存在某个单独的属性或方法
                    2. 对象可以自由地扩展静态的属性和方法(自己本身的属性和方法,可以继承给子级)

                    给对象扩展静态属性和方法:
                        extend({}, ...)
                            -> 第一个参数是要扩展的对象
                            -> 第二及第二个以上的参数是要遍历的对象



        

        内置对象 Object 的常用方法

        1. Object.create(obj) -> 创建一个新对象，使用obj为新对象的__proto__ (obj可为null)

            一个参数 var obj = Object.create( _prototype )
            
            两个参数 var obj = Object.create( _prototype, {
                        name : {
                            value : 'xuyede',
                            enumerable : true,
                            configurable : false,
                            writable : true
                        },
                        age : {
                            enumerable : true,                      set/get 和  writable/value  只能存在一组
                            configurable : false,
                            get() {
                                return 10
                            },
                            set(value) {
                                age = value
                            }
                        }
                    } )
                ->
                    obj = {
                        name : 'xuyede',
                        age : 10
                    }


        2. Object.assign(target, sources ...) -> 将所有可枚举属性的值从一个或多个源对象复制(不可枚举和继承属性不能)到目标对象，返回目标对象
            -> 如果需要深拷贝，则
                        var result = Object.assign(target, sources ...)
                        JSON.parse(JSON.stringify(result));

        3. Object.defineProperty(obj, prop, descriptor) -> 直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象
            -> descriptor 属性描述符
                {
                    value : prop要修改的值,
                    enumerable : prop是否可枚举(true/false),
                    configurable : prop是否可删除(true/false),  -> 这三个默认为false
                    writable : prop是否可更改值(true/false),
                    get() {
                        return 
                    },
                    set(value) {

                    }
                }

                get/set 和  value/writable  成组存在,且只能同时存在一组

        4. Object.entries(obj) -> 把对象转化为数组 [[key,value], ...]，返回数组
        


        5. Object.freeze(obj) -> 冰洁该对象，视为不可拓展的对象，啥都不能做，返回冻结对象
           Object.isFrozen(obj) -> 判断是否被冻结

        6. Object.preventExtensions(obj) -> 使该对象变为不可拓展的对象
           Object.isExtensible(obj) -> 判断是否为可拓展的对象
                
        7. Object.seal(obj) -> 封闭该对象，视为不可拓展的对象，但可以改变现有的属性
           Object.isSealed(obj) -> 判断是否为封闭函数



        8. Object.keys(obj) -> 返回一个含有该对象的可枚举的属性的字符串数组
            -> var obj = {"name" : "sunday", "age" : 18}
               Object.keys(obj) -> ["name", "age"]

        9. Object.values(obj) -> 返回一个含有该对象的可枚举的属性的值得字符串数组
       
        10. Object.prototype.hasOwnProperty(prop) -> 枚举对象时过滤原型链上的属性

        11. Object.prototype.isPrototypeOf(obj) -> 一个对象是否存在于另一个对象的原型链上
            -> 检查 baz 对象是否继承自 Foo.prototype
                if (Foo.prototype.isPrototypeOf(baz)) {
                     // do something safe
                }   

        12. Object.getOwnPropertyDescriptor(obj, prop) -> 获取对象某属性的描述对象
            ->
                let obj = { foo: 123 };
                Object.getOwnPropertyDescriptor(obj, 'foo')
                //  {
                //    value: 123,
                //    writable: true,   可修改  
                //    enumerable: true,     可枚举
                //    configurable: true        可删除
                //  }

                目前，有四个操作会忽略enumerable为false的属性
                ->
                    for...in循环：只遍历对象自身的和继承的可枚举的属性
                    Object.keys()：返回对象自身的所有可枚举的属性的键名
                    JSON.stringify()：只串行化对象自身的可枚举的属性
                    Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性

        13. Object.setPrototypeOf() -> 用来设置一个对象的prototype对象，返回参数对象本身
            ->
                let proto = {};
                let obj = { x: 10 };
                Object.setPrototypeOf(obj, proto);

                proto.y = 20;
                proto.z = 40;

                obj.x // 10
                obj.y // 20
                obj.z // 40

        14. Object.getPrototypeOf() -> 用于读取一个对象的原型对象
            ->
                function Rectangle() {
                    // ...
                }

                const rec = new Rectangle();

                Object.getPrototypeOf(rec) === Rectangle.prototype
                // true

                Object.setPrototypeOf(rec, Object.prototype);
                Object.getPrototypeOf(rec) === Rectangle.prototype
                // false

        15. super -> 指向当前对象的原型对象，目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法，其他的都报错
            ->
                const proto = {
                    foo: 'hello'
                };

                const obj = {
                    foo: 'world',
                    find() {
                        return super.foo;
                    }
                };

                Object.setPrototypeOf(obj, proto);
                obj.find() // "hello"
 
    -->
</body>
</html>