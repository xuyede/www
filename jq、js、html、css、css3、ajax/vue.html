<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 
            * vue的生命周期
                                    new Vue()
                                        
                               init Event&Lifecycle 
                                        |
             *beforeCreate  <-          |
                                        |
                            init injections&reactivity
                                        |
                  *Created  <-          |
                                        |           
                                 Has 'el' option?   ——————————————>   no
                                        |                             |  
                                   yes  |                 when vm.$mount(el) is called
                                        |                             |
                              Has 'template' option?  <———————————————|                  
                                        |
                    ____________________|____________________
                   |                                         |
                  yes                                        no
                                                          
            compile template                            compile el's
                  into                                    outerHTML
            render function*                            as template*

                   |                                         |
                   |_________________________________________|
                                        |
                 *beforeMount  <-       |          
                                        |
                                   Create vm.$el
                                    and replace
                                   'el' with it
                                        |
                                        |
                 *mounted      <-       |     
                                        |            >   when data changes  
                                        |           /                      \
                                     _________     /                        \   -> *beforeUpdate
                                    |         |   /                          \   
                                    | Mounted |                               > _____________
                                    |_________|                                |             |
                                        |     <                                | Virtual DOM |   
                                        |      \                               |   re-render |
                                        |       \                              |  and patch  |
                                        |        \                             |_____________|
                                        |         \___________________________/
                                        |                  *updated
                                        |
                                        | 
                            when vm.$destroy() is called  
                                        |
            *beforeDestroy <-           |                         
                                        |

                        Teardown watchers, child components
                                and event listeners
                                        |
                                        |
                                   ___________
                                  |           |
                                  | Destroyed |     -> *destroyed
                                  |___________|


                钩子函数
                1) beforeCreate/ created -> 创建完 Vue实例
                    beforeCreate -> 初始化事件,生命周期
                    created -> 把相应的属性挂到 vue实例上

                    执行完 created后,组件实例化完毕,开始根据 template为模板通过 render编译虚拟 DOM
                    注意: 如果没有 el且没有通过 vm.$mount声明一个挂载点,则生命周期结束

                2) beforeMount/ mounted -> 将虚拟 DOM的内容挂载到挂载点上,并渲染页面
                    beforeMount -> 虚拟 DOM已经编译完毕,把 el的数据提升到 Vue实例上
                    mounted -> 以 el为模板创建 vm.$el,并把虚拟 DOM挂载到 vm.$el上,开始渲染页面,渲染完成后进入 Mounted状态,等待数据的更新

                3)beforeUpdate/ updated -> 只有在页面中应用的数据更新才会触发这两个函数
                    beforeUpdate -> 组件更新前,虚拟 Dom的数据更新完毕,准备和旧的虚拟 DOM作比较
                    updated -> 组件更新,页面显示最新内容

                    注意: 如果组件更新的内容和之前的一样,则不触发更新函数

                4)beforeDestroy/ destroyed -> 调用 vm.$destroy(), 生命周期结束
                    beforeDestroy -> 组件销毁前
                    destroy -> 组件销毁


            Vue的特点 :
                1. 并不直接操作 DOM,通过虚拟 DOM来实现数据的更新以及对页面的渲染
                2. MVVM模式 (观察者)
                    ____________________________________________________
                    | M Model 模型 -> 后端传递的数据                     |
                    | V View 视图 -> 需要展示的页面                      |
                    | VM ViewModel 视图模型 -> 连接 view和 model的桥梁   |
                    |                                                   |
                    |             ->                  DOM事件监听        |
                    | Model   (数据绑定)   ViewModel      <->      View  |
                    |             <-                                    |
                    |___________________________________________________|    

                    ViewModel的两个方向
                        1) 将 Model -> View : 数据绑定
                        2) 将 View -> Model : DOM事件监听 

                    在 Vue中, 虚拟Dom(js对象)和 View为映射关系, Model和虚拟DOM(js对象)为绑定关系


            













            1.数据绑定 : {{ 变量 }}  Object.defineProperty()在底层通过get / set，利用观察者模式对数据进行监听

            2.指令 -> 指令后面接一个js表达式 (如果为字符串,则表示一个变量)
                1.绑定事件指令
                    v-on:eventType = 'func'  ->  缩写 @eventType = 'func'
                        v-on:click = 'countIncrease' -> @click = 'countIncrease'

                    v-on:click = "doThis" //函数名
                    v-on:click = "attach = !attach" //表达式  
                    v-on = "{mousedown : doThis, mouseup : doThat}" //对象，一组事件绑定


                2.绑定属性指令
                    v-bind:prop = 'variate'  ->  缩写 :prop = 'variate'
                        v-bind:href = 'ImageUrl' -> :href = 'imageUrl'

                    v-bind:src = "imageSrc" //属性名
                    v-bind:src = "'/path/to/images/' + fileName" //内联字符串拼接

                    //class 绑定
                    v-bind:class="{ red: isRed }" //isRed为true时添加
                    v-bind:class="classObj" //绑定一个返回对象的computed属性
                    v-bind:class="classA" //绑定一个属性
                    v-bind:class="[classA, classB]" //绑定一个数组，数组的元素为属性
                    v-bind:class="[isActive ? activeClass : '', errorClass]" //数组加三目表达式组合
                    v-bind:class="[{ active: isActive }, errorClass]" //数组加对象组合

                    //style 绑定
                    v-bind:style="{ fontSize: size + 'px' }" //绑定单个
                    v-bind:style="styleObject" //styleObject为一个样式对象属性
                    v-bind:style="[styleObject1, styleObject2]" //绑定多个样式对象属性


                3.双向数据绑定指令 常用于 <input>、<textarea> 及 <select> 也可以用 

                    <input v-model = 'variables'> 
                    //简写
                    <input :value = 'variables'
                           @input = 'variables = $event.target.value'
                    >

                    <input v-model.lazy = 'variables' />   -> .lazy把 input事件改为 change事件

                4.元素显示隐藏指令
                    1) 条件渲染元素 v-if / v-self- if / v-self / v-show
                        
                        -> 元素的显示隐藏为 append/remove 操作
                            v-if = 'isTrue' //根据表达式的值的真假条件渲染元素(remove)
                            v-else-if = 'isTrue' //v-if 的 else if 块
                            v-else //为 v-if 或者 v-else-if 添加 else 块
                                ->可以使用 <template> 元素包裹, <template> 元素不显示在DOM节点中

                        -> 元素的显示隐藏为 display: block/none 操作
                            v-show = 'isTrue' //根据表达式之真假值，切换元素的 display CSS 属性
                                -> v-show 不支持 <template> 元素，也不支持 v-else

                        -> key -> 管理可复用的元素
                        

                    2) 列表渲染元素 v-for
                        
                        -> 一个数组的v-for
                            v-for = "item in items" //item为数组元素迭代的别名
                            v-for = "(item, index) in items" //index为每位数组的索引


                        -> 一个对象的v-for -> 按照Object.keys()的结果遍历的
                            v-for="value in object" //value为对象的属性值
                            v-for="(value, key) in object" //key为对象的属性名
                            v-for="(value, key, index) in object" //index为参数的索引

                        -> 遍历的时候给每一项添加一个key值作为唯一的标识,解决模板复用的问题
                            v-for="item in items" :key="item.id"











                    ____________________________________________________________________________________
                    |                                                                                   |
                    |    Vue的数据监听是依靠 Object.defineProperty()激活 set/ get去动态获取数据的变化      |
                    |                                                                                   |
                    |    数组更新检测: (数组没有 set/ get方法,只能改变栈的地址或者使用Vue自己定义的数组方法) |
                    |       vue把一些数组的方法重写，使得这些方法执行时可以更新视图                         |
                    |           push / pop / shift / unshift / splice / sort / reverse                  |
                    |                                                                                   |
                    |        利用索引直接设置一个项时，不能检测数组的变动                                  |
                    |            Vue.set(vm.items, indexOfItem, newValue)                               |
                    |                                                                                   |
                    |    对象更新检测                                                                    |
                    |        Vue 不能检测对象属性的添加 /删除 (对象的修改可以检测,用的是 set钩子修改)       |
                    |            Vue.set(object, key, value)                                            |
                    |            vm.$set(object, key, value)                                            |
                    |                                                                                   |
                    |            添加多项属性时，用一个新对象做为新载体                                    |
                    |            vm.userProfile = Object.assign({}, vm.userProfile, {                   |
                    |                age: 27,                                                           |
                    |                favoriteColor: 'Vue Green'                                         |
                    |            })                                                                     |
                    |___________________________________________________________________________________|   

                        














            3.指令修饰符：
                .stop 取消冒泡
                .prevent 取消默认事件
                .once 只调用一次
                .enter 回车调用
                .space 空格调用
                .esc esc调用
                .lazy input事件->change事件


            4.属性： get set
                1)methods : {}  ->  方法，定义的函数如果放进该属性中，则会实时更新，每当有事件触发时都是执行，不管作用的数据是否在函数里
                    
                2)computed : {}  -> 计算属性，基于函数和属性的依赖进行缓存的，计算属性只有在它的相关依赖属性发生改变时才会重新求值, （根据已有属性派生出的新属性，计算属性由已有属性决定, 可以缓存数据）
                
                3)watch : {}  ->  侦听属性，监听已经定义的属性(data中)，如果有改变，则触发对应的函数,否则不触发

                4)data : {}  ->  数据定义及初始化

                5)filters : {}  ->  过滤器, 一个函数, 第一个参数默认为要处理的字符串, {{ meg | myFilter }} / v-bind:id = 'fId | Sid'

                6)render : function (createElement) {} -> 渲染,接受一个 createElement方法,把对象渲染成 DOM节点(template底层实现)


            5.实例属性：
                1) vm.$refs -> 存放dom节点 (当一个普通元素加上ref属性后，会把该元素存放到实例的$refs对象上,可以进行DOM操作，但不应该用在数据绑定上)

                2) vm.$data -> 存放Vue实例的data对象属性

             
            8.Vue component
                1) Gobal Component
                        //basic writing
                        Vue.component('xyd-counter', {
                            template : `<button @click = 'count ++'>You clicked me {{ count }} times</button>`,
                            data() {
                                return {
                                    count : 0
                                }
                            },
                            methods : {}
                            ...
                        })

                        //mounted element
                        <div id="app">
                            <xyd-counter></xyd-counter>
                        </div>
                        ___________________________________
                        <div id="app"></div>

                        
                        //mount to mounted element
                        new Vue({ el : '#app' })
                        ___________________________________
                        
                        new Vue({
                            el : '#app',
                            template : '<xyd-counter></xyd-counter>'
                        })
                    

                    *warning
                    1) data in component -> Must Be a Function
                        data() {
                            return {
                                count : 0
                            }
                        }

                    2) each component must have a single root element




                2) Local Component
                        //Define A Components
                        const xydCounter = {
                            template : `<button @click="count++">you clicked me {{ count }} times</button>`,
                            data() {
                                return {
                                    count : 0
                                }
                            },
                            ...
                        }

                        new Vue({
                            el: '#app',
                            components : {
                                xydCounter,
                                ...
                            }
                        })

                        //main template
                        <div id="app">
                            <xyd-counter></xyd-counter>
                        </div>

            9. props -> set into child component -> parent to child
                1)  basic writing
                    //set in component
                    Vue.component('xyd-counter', {
                        template : <button @click="count++">  {{name}} clicked me {{count}} times</button>`,
                        props : {
                            myname : String  //rule the name to be a String type 
                        },
                        data() {
                            return {
                                name : this.myname,
                                count : 0
                            }
                        },
                        methods : {
                            change() {
                                this.myname = 'Sunday';  -> Error:don't change the props's prop, but if it is a object, you can do that
                            }
                        }
                    })

                    //set in Vue
                    new Vue({
                        el : '#app',
                        data : {
                            name : 'xuyede'
                        }
                    });

                    //set in element
                    <div id="app">
                        <xyd-counter
                            :myname='name' 
                        ></xyd-counter>
                    </div>
                
                2)step of parent transfer data to child
                    first : defined the props in the component, and defined a variable to accept the data
                        props : {
                            myname : String
                        }

                    second : bind the props's variable by v-bind with the appoint data from parent
                        <xyd-counter
                            :myname = 'name' 
                        ></xyd-counter>

                3)props usage
                    parent can transfer own data by v-bind to child
                    child can accept parent's data in the props, and
                    you can deal the props's attr by this, like useing data attr

                    you can list props as an object to rule every attr to be a specific type of value
                    props: {
                        title: {
                            type : String,  //rule the title is the type of String
                            required : true,  //must transfer the data for title
                            default : 'title',  //defaults data
                        },
                        likes: Number,
                        isPublished: Boolean,
                        commentIds: Array,
                        author: Object
                    }
                
                4)props is the One-Way Data Flow
                    when the parent attr updates, it will flow down to the
                    child, but not the other way around.
                    
            10. $emit -> set into component -> child to parent
                1)basic writing
                    //set in element
                    <div id='app'>
                        <xyd-name
                            :myname = 'name'
                            @change-name = 'changeName'
                        ></xyd-name>
                    </div>

                    //set in component
                    Vue.component('xyd-name', {
                        props : {
                            myname : String
                        },
                        template : `<button @click='$emit("change-name", "xudeye")'>{{bindName}}</button>`,
                        computed : {
                            bindName() {
                                return this.myname;
                            }
                        },
                        // you can watch the attr change and call this.$emit('', '');
                    })

                    //set in Vue
                    new Vue({
                        el : '#app',
                        data : {
                            name : 'xyd'
                        },
                        methods : {
                            changeName(event) {
                                this.name = event;
                            }
                        }
                    })
                    
                2)step of transfer data from component
                    first : use $emit to create a selfEvent and set the data
                       this.$emit('self-event', data)

                    second : bind the selfEvent in the selfTag and deal as the normal event
                        <div>
                            <xyd-name
                                @self-event = '...' / '$event'
                            ></xyd-name>
                        </div> 

                    thrid : the data from component is storage in the methods first params name $event($event can also use in the point)
              
            11. parent tranfer a DOM ele to child
                    in parent
                        ->  <xyd-component>
                                <p slot='slot1'>this for child</p>
                            </xyd-component>

                    in child 
                        ->  <slot name="slot1"></slot>

            12. child tranfer a template to parent to rander
                    in child 
                        ->  <slot v-for="list in lists" :list="list"></slot>  //data will tranfer by v-bind

                    in parent
                        ->  <xyd-slot>
                                <li slot-scope="prop">{{prop.list.title}}</li>  //accecpt data by slot-scope
                            </xyd-slot>

                            tag <li> will rander depend on <slot>'s order

            13. dynamic component
                    -> you can use tag of <component> to change the component dynamic, like this
                        <div id="app">
                            <keep-alive>
                                <compnent :is="witchComp"></compnent>
                            </keep-alive>
                            <button @click="nextOpt">next</button>
                        </div>
                        //define component
                        const xydInput = {
                            template : `<input type="text"/>`
                        }

                        const xydPassword = {
                            template : `<input type="password"/>`
                        }
                        
                        new Vue({
                            el : '#app',
                            data : {
                                witchComp = 'xydInput'
                            },
                            components : {
                                xydInput, xydPassword
                            },
                            methods : {
                                nextOpt() {
                                    this.witchComp = this.witchComp === 'xydInput' ? 'xydPassword' : 'xydInput';
                                }
                            }
                        })
            
            14. using v-model on component
                1)normal v-model
                    <input type='text' v-model = 'variables'>
                    //you can use v-on and v-bind to imitate v-model
                    <input type='text'
                        :value = 'variables'
                        @input = 'variables = $event.target.value'
                    >

                2)component v-model
                    <xyd-input type='text'
                        :value = 'variables'
                        @input = 'variables = $event'
                    ></xyd-input>

                    //make sure it can work though, the <input> inside the component must like 
                    Vue.component('xyd-input', {
                        props : {
                            value : {
                                type : String,
                                required : true
                            }
                        },
                        template : `
                            <input type='text
                                :value = 'value'
                                @input = '$emit("input", $event.target.value)'
                            >
                        `,
                    })

                    //then you can use the v-model on component
                    <xyd-input type='text'
                        v-model = 'variables'
                    ></xyd-input>
                
                3)step of using v-model on component
                    first : bind the value attr to a value prop in props
                    second : on input, emit its own custom input event with the new value

     -->
    <!-- 
        vue-cli

            1.install vue-cli
                -> npm install -g vue-cli

            2.create a vue project
                -> vue init template projectName
                   cd projectName
                   npm install
                   npm run dev

    -->
    <!--
        unifile component
            1.App.vue
                depend on three parts
                1) template -> html
                2) script -> vueInstance's config 
                3) style -> css

            2.each unifile-compnent must register in main.js or vue file by import and Vue.component before use it
                import Announcement from './Announcement.vue';
                Vue.component('xyd-announcement', Announcement);
                // then you can use tag of <xyd-announcement> in vue file or main.js

            3.css scoped 
                default global style
                use <style scoped> to be a local style
    -->
    <!--
        vue-router

            1.npm install vue-router -D

            2.base write
                ->main.js
                    import Vue from 'vue'
                    import VueRouter from 'vue-router'
                    import Home from './components/Home.vue'
                    import App from './App.vue'
                    import HelloWorld from './components/HelloWorld.vue'

                    // module programming, must reference Vue.use(VueRouter)
                    Vue.use(VueRouter)

                    //config router
                    const routes = [
                        //the path and the corressponding component
                        {path : '/', component : Home},
                        {path : '/helloworld', component : HelloWorld}
                        {path : '*', redirect : '/'}   -> link to '/' when you enter a error route
                    ]
                    //instance a Vuerouter
                    const router = new VueRouter({ routes })

                    new Vue({
                        router
                        template : `<App/>`
                        components : { App }
                    }).$mount(#app)
                
                ->App.vue
                <template>
                    <div id="app">
                        //set the router url
                        <rounter-link to = "/">HOME</rounter-link>
                        <rounter-link to = "/helloworld">HelloWorld</rounter-link>

                        //show the root router
                        <rounter-view></rounter-view>
                    </div>
                </template>

            3.about <router-link>
                -> <router-link> default tag <a>, you can set tag( <router-link tag='div'> ) to change it

                -> dynamic bind attr 'to'
                    <router-link :to = "homeLink"></router-lin>
                    data : {
                        homeLink : '/'
                    }

            4.named routes
                u can set a name for routes like
                ->  const routes = [
                        {path : '/', name : 'aboutLink', component : About}   // this routes named aboutLink,then u can use it as a path
                    ]

                    <router-link :to = "{name : 'aboutLink'}">About</router-link>
                    // or
                    <router-link :to = "aboutLinkMeg">About</router-link>
                    
                    data() {
                        return {
                            aboutLinkMeg : {name : 'aboutLink'}
                        }
                    }

            5.dynamic route matching 
                u can set a dynamic route and adapt to special path like
                ->  const routes = [
                        {path : '/about/:classes', name : 'aboutLink', component : About}
                    ]

                    <router-link :to = "aboutLinkMeg">About</router-link>   // will redirect to /about/xuyede
                    // or
                    data() {
                        return {
                            aboutLinkMeg : {name : 'aboutLink', params : {classed : 'xuyede'}}
                        }
                    }

                    you can also get the classes by $route.params.classes in the assign module

            6.programmatic routes (operate the history stack)
                1) this.$router.push() -> push a new entry into the history stack
                    ->
                        this.$router.push('/menu')
                        this.$router.push({name : 'aboutLink', params : {}})
                        this.$router.push({path : '/login'})

                2) this.$router.replace() -> change a entry of history stack
                    ->  
                        the only difference with push is that it navigates without pushing a new history entry
                        it replaces the current entry

                3) this.$router.go() -> go to a assign history stack
                    -> 
                        this.$router.go(-1) -> go back a history

            7.Nested routes( set attr of children )
                u can use attr of children to set a second routes
                ->  const routes = [
                        { 
                            path : '/about', 
                            name : 'aboutLink', 
                            component : About,
                            resirect : '/abou/contact',  // default path
                            children : [
                                {
                                    path : '/about/conact',
                                    name : 'contactLink',
                                    component : Contact
                                },
                                {
                                    path : '/about/history',
                                    name : 'historyLink',
                                    component : History
                                }
                            ]
                        },
                        {
                            path : '/admin',
                            name : 'adminLink',
                            component : Admin
                        }
                    ]
                
            8.global Guards -> beforeEach()
                const router = new VueRouter({})

                router.beforeEach( (to, from, next) => {
                    //to -> the target router path
                    //from -> the origin router path
                    //next -> resolve this hook, Make sure to always call the next function

                    console.log(to.path) 
                    next()  //make sure call the next to resolve th hook
                })

            9.Per-Route Guard -> beforeEnter
                //operate like global guard
                const router = new VueRouter({
                    routes: [
                        {
                            path: '/foo',
                            component: Foo,
                            beforeEnter: (to, from, next) => {
                                // ...
                                next(); 
                            }
                        }
                    ]
                })

            10.In-Component Guards
                // two key function
                
                1) beforeRouterEnter(to, from, next) -> it run before the component render, so you can not use 'this' directly
                    export default {
                        data() {
                            return {
                                name : 'xuyede'
                            }
                        },
                        beforeRouteEnter (to, from, next) {
                            // ...
                            next( vm => alert(vm.name))   //use callback to get the instance of this component
                        }
                    }

                2) beforeRouterLeave(to, from, next) > it run before the route skip to other route, use 'this' normal
                    export default {
                        data() {
                            return {
                                name : 'xuyede'
                            }
                        },
                        beforeRouteLeave (to, from, next) {
                            // ...
                            alert(this.name)
                            if (confirm( this.name + 'are u ready to exit?') === true) {
                                next();
                            } else {
                                next(false)
                            }
                        }
                    }

            11.scroll behavior
                // oprate in router instance
                const router = new VueRouter({
                    routes,
                    mode : 'history',
                    scrollBehavior(to, from, savedPosition) {
                        // return { x : 0, y : 0 }
                        // return { selector : '' } -> tag-selector
                        if (savedPosition) {
                            return savedPosition   // history position
                        } else{
                            return {
                                x : 0,
                                y : 0
                            }
                        }
                    }
                })


            12.reuse about <router-view>
                u can set an attr of name to <router-view> like
                -> 
                //App.vue
                <router-view name = "history"></router-view>
                //routes.js
                {
                    path: '/', name: 'homeLink', components: {
                        default : Home,   // default path
                        history : History,   // <router-view> name history 
                        contact : Contact   // <router-view> name contact
                    }
                },

            


        vue-resource

            1. npm install vue-resource --save-dev

            2.
            -> import VueResource from 'vue-resource'

               normal use in the created() 

               created() {
                   this.$http.get().then( data => {} )
               }
    -->     
</body>
</html>