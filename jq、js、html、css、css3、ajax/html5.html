<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 

            1. canvas 画布
                -> 放大会失帧
            
                操作：
                    1) 获取canvas对象    var oCanvas = ***;    -> 画布
                    2) 获取canvas上下文  var ctx = oCanvas.getContext('2d');    -> 画笔
                    3) 设置宽高  oCanvas.width = '500'
                                oCanvas.height = '500'    
                                
              
             画布图形的旋转 ->
                    清屏：ctx.clearRect(startX, startY, width, height) 
   保存改变canvas前的状态：ctx.save();
         改变画布原点位置：ctx.translate(x, y) 默认为0 0
             绕着原点旋转：ctx.rotate(deg)
               填充的颜色：ctx.fillStyle = '#f0f0f0' 
                 填充矩形：ctx.fillRect(startX, startY, width, height) 相对于原点
    恢复改变canvas前的状态：ctx.restore();

              画笔移动到：ctx.moveTo(x, y)
   从当前点绘制直线到x, y：ctx.lineTo(x, y)
                描边大小：ctx.lineWidth = 10
         闭合路径当前路径：ctx.closePath()
                    描边：ctx.stroke()      -> .stroke()和.fill()作用域当前路径
                    填充：ctx.fill()
               开启新路径：ctx.beginPath()
                   画矩形：ctx.rect(startX, startY, width, height)  -> 配合.fill()或.stroke()
                    矩形：ctx.fillRect()/.strokeRect()  -> 单独开启子路径
                    弧形：ctx.arc(x, y, r, 起始角, 结束角：2*Math.PI, 方向：false顺/true逆)
                        -> 一个圆，顺/逆时针， 右 0/2*Math.PI， 下 0.5*Math.PI， 左 1*Math.PI， 上 1.5*Math.PI
                直角弧形：ctx.arcTo(startX, startY, endX, endY, r) -> 起点和终点在同一x/y上
              填充背景图：ctx.drawImage(image, clipX, clipY, clipW, clipH, X, Y, W, H)  -> 不裁剪的话不用写clip*参数
                写入文字：ctx.fillText(content, posX, posY)
            渐变背景颜色：var bg = ctx.createLinearGradient(startX, startY, endX, endY);
                         bg.addColorStop(%, color);
                         ctx.fillStyle = bg;
                         ctx.fillRect(0, 0, oCanvasW, oCanvasH);

                         -> 45deg,#6fc7b5 0%,#13bdce, 20%,#0094d9 40%, #5a3694 60%, #ee4d74 80%, #f58c58 100%
     -->
     <!-- 

            2.SVG 可缩放矢量图形 (标签 -> css操作)
                -> 放大不失帧

                所有标签都要放到<svg></svg>里

                直线
                    -> <line x1='' y1='' x2='' y2=''></line>
                矩形
                    -> <rect x='' y='' width='' height='' rx='' ry='' style=''></rect>
                        ->  style='' 定义css样式 fill:填充颜色 stroke-width:边框宽度 stroke:定义边框颜色
                                                fill-opacity stroke-opacity:透明度
                            rx/ry 圆角
                圆形
                    -> <circle cx='' cy='' r='' style=''></circle>
                        ->  style='' 定义css样式 fill:填充颜色 stroke-width:边框宽度 stroke:定义边框颜色
                                                    fill-opacity stroke-opacity:透明度
                椭圆
                    -> <ellipse rx='' ry='' cx='' cy='' style=''></ellipse>
                        ->  style='' 定义css样式 fill:填充颜色 stroke-width:边框宽度 stroke:定义边框颜色
                                                    fill-opacity stroke-opacity:透明度
                多边形
                    -> <polygon points="" style=""/>
                        ->  points: 点， 会闭合
                折线
                    -> <polyline points="" style=""/>
                        ->  points: 点， 不会闭合

                *路径
                    -> <path d="" fill="" stroke="" stroke-width="" />
                        ->  M = moveto
                            L = lineto
                            H = horizontal lineto
                            V = vertical lineto
                            C = curveto
                            S = smooth curveto
                            Q = quadratic Belzier curve
                            T = smooth quadratic Belzier curveto
                            A = elliptical Arc
                            Z = closepath
                            大写字母为绝对路径，小写字母为相对路径

                            A -> 圆弧(两个椭圆的交点为起始点的4条圆弧)
                                A rx ry 旋转(*deg):不旋转(0) 大圆弧(1):小圆弧(0) 顺时针(1):逆时针(0) endX endY  
                                
                stroke 
                    ->  1. stroke : 描边颜色(none/color/currentColor:父级颜色)
                        2. stroke-width : 描边线条宽度
                        3. stroke-linecap : 描边端点表现方式(butt/round/square)
                        4. stroke-linejoin : 描边转角的表现方式(miter/round/bevel)
                        5. stroke-dasharray： 10px;     按数值切分
                        6. stroke-dashoffset: 20px;     移动数值距离，正数为左运动，负数为右运动
                        7. getTotalLength() : 获取路径总长度 -> path标签
                        8. getPointAtLength(x) : 获取路径上距离起始点x长度的点的坐标 -> path标签

                viewBox="0, 0, xRatio, yRatio"
                    -> 当svg加上该属性后，svg里面的元素的单位变为
                                svg宽、高(哪个小选哪个) / xRatio、yRatio(哪个大选哪个)
                
                preserveAspectRatio="xMidYMid meet"
                    Mid 居中 Min 左 Max 右
                    meet slice

                js生成svg标签
                    -> 
                        svg为xml的标签，js动态生成是需要命名空间
                            -> var char = 'http://www.w3.org/2000/svg';

                        创建： var svg = document.createElementNS(char, 'svg');
                        属性用 setAttribute 设置

      -->
      <!-- 
            优化动画 ： requestAnimationFrame() -> 改变里面的this用bind方法

            1000ms / 60fps -> 16 ms/fps

            var timer = requestAnimationFrame(function () {
                ...
            });
            if (...) {
                cancelAnimationFrame(timer);
            }

            兼容性，引用 requestAnimationFrame.js 文件 (低版本浏览器使用setTimeout兼容) 


       -->
       <!-- 
            客户端存储

            1.storage (同源策略) 可以存5MB左右数据  只在浏览器保存，不参与服务器的通信  ie8以后的版本
                -> 只能存储字符串形式数据(存取对象用JSON.stringify/JSON.parse)
                    
                1)  localStorage    永久，除非手动删除

                2)  sessionStorage(受窗口限制,不同窗口不能获取)  临时，窗口关闭就没了

                方法:
                    -> localStorage.setItem('name', 'sunday')
                    -> localStorage.getItem('name')
                    -> localStorage.removeItem('name')
                    -> localStorage.clear() 清除所有

            2.cookie (同源策略)
                -> navigator.cookieEnabled 查看浏览器是否启用cookie

                详细看网络部分知识
        -->
        <!-- 

            历史记录
                1.history.back()
                2.history.forward()
                3.history.go(n)

                添加/替换时不会刷新页面,所以一般用来传标识(?one ...),适用于单页面切换
                history.pushState(state, title, url); -> 添加一条历史记录
                history.replaceState(state, title, url); -> 替换当前的历史记录

                state
                    -> 一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数中
                       如果不需要这个对象，此处可以填null
                title
                    -> 新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null 
                url
                    -> 新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址


                事件：
                    popstate : 历史记录发生改变时触发(pushState和replaceState的state会传到回调函数中)
                               但pushState和replaceState不会触发
                               可配合ajax切换历史记录显示
                               
                    hashchange : 当页面hash值(#..)改变时触发，常用于构建单页面应用
         -->
         <!-- 

            异步 worker -> 受同源策略限制,不能获取document、window，所以无法处理dom，只能处理数据

                开始一个worker
                    -> var worker = new Worker('./worker.js');

                结束一个worker
                    -> 
                        close() 在worker.js中调用(工人自己不干了) 
                        terminate() 在主线程中调用(老板炒了你) -> 推荐用这个,由主线程控制链接
                    
                    1) 主线程
                        var worker = new Worker('./worker.js');
                        -> 接收数据
                        worker.addEventListener('message', function (e) {
                            deal(e.data);
                            // 结束worker
                            worker.terminate();
                        });
                        -> 发送数据
                        worker.postMessage(data);
                        function deal (data) {}

                    2) worker.js
                        -> 接收数据
                        addEventListener('message', function (e) {
                            var result = deal(e.data);
                            postMessage(result);
                        });
                        function deal (data) {}
                        
          -->

          <!-- 
                位置信息
                    -> window.navigator.geolocation

                    1. .getCurrentPosition(success, error, options) => 获取当前位置信息
                        -> 
                            success 成功的回调
                            error 失败的回调
                            options 参数

                            成功时返回Geoposition对象，包含
                              ->
                              coords对象
                                latitude 纬度
                                longitude 经度
                                altitude 海拔
                                accuracy 定位精准度，单位m
                                altitudeAccuracy 海拔精准度，单位m
                                heading 方向
                                speed 速度
                            
                            失败时返回PositionError对象，包含
                              ->
                                code
                                message 错误信息
                                用户拒绝 code = 1
                                获取不到 code = 2
                                连接超时 code = 3

                            options
                              ->
                                enableHighAccuracy 是否需要高精度位置默认false
                                timeout 单位ms 请求超时时间 默认infinity
                                maximumAge 单位ms，默认0 设置多少则该时间段内不更新地理信息

                    2.  .watchPosition(success, error, options) => 监视位置变化,地理位置发生变化时，自动调用
                        clearWatch() => 清除位置监听

                        与计数器启动/关闭相似
                            var pos = window.navigator.geolocation.watchPosition(*, *, *);
                                //do something
                            clearWatch(time);

                监听加速度定位
                    devicemotion

                    window.addEventListener('devicemotion', function (event) {
                        console.log(event);
                    })
                    event ->
                        1. accelerationIncludingGravity 重力加速度,z轴方向加了9.8,在x,y方向上的值两者相同
                        2. acceleration 重力加速度     需要陀螺仪
                        3. rotationRate(alpha, beta, gamma) 旋转速率
                        4. interval 获取的时间间隔

           -->  
</body>
</html>